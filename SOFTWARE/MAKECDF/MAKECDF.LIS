                                Source Listing                  11-SEP-1997 17:17:27    DEC C V4.0-000                      Page   1
                                                                11-JUN-1996 12:50:10    SMS1:[WIND.SOFTWARE.MAKECDF]MAKECDF.C;13

	      1 #include "makecdf.h"
	   2672 
	   2673 main(argc,argv)
	   2674 int argc;
	   2675 char *argv[];
	   2676 {
	   2677 
	   2678   /* declare local variables */
	   2679   long i,j,ierr,icnt,ifile,iflag,OLidx,vnum,velem,snum,pvnum,CDFrec;
	   2680   float *rnum;
	   2681   double depoch;
	   2682   char pname;
	   2683   char lfileid[80]="";
	   2684   char newname[80]="";
	   2685 
	   2686   if (argc != 5) {
	   2687     printf("ERROR: Wrong  number of makeCDF command parameters!\n");
	   2688     printf("ERROR: Translation Aborted.\n");
	   2689     exit(EXIT_FAILURE);
	   2690   }
	   2691 
	   2692   /* Initialize Run time parameters */
	   2693   strcpy(RPARMS.infname,""); strcpy(RPARMS.ffdfname,"");
	   2694   strcpy(RPARMS.incdfname,""); RPARMS.progress=0L; RPARMS.debug=0L;
	   2695   RPARMS.sendtolog=0L; RPARMS.maxlogrecs=100L; RPARMS.sendtoterm=1L;
	   2696   RPARMS.haltateof=1L; RPARMS.numrecs=0L; RPARMS.autocase=1L;
	   2697 
	   2698   /* Initialize output CDF information */
	   2699   OUTCDF.outCDFid=0L; OUTCDF.encoding=0L; OUTCDF.CDFrec=0L;
	   2700 
	   2701   /* extract command line parameters from calling sequence */
	   2702   for (i=0;i<strlen(argv[0]);i++) pname = argv[0][i];
	   2703   for (i=0;i<strlen(argv[1]);i++) RPARMS.infname[i]=argv[1][i];
	   2704   RPARMS.infname[i]='\0';
	   2705   for (i=0;i<strlen(argv[2]);i++) RPARMS.ffdfname[i]=argv[2][i];
	   2706   RPARMS.ffdfname[i]='\0';
	   2707   for (i=0;i<strlen(argv[3]);i++) RPARMS.incdfname[i]=argv[3][i];
	   2708   RPARMS.incdfname[i]='\0';
	   2709   for (i=0;i<strlen(argv[4]);i++) RPARMS.outcdfname[i]=argv[4][i];
	   2710   RPARMS.outcdfname[i]='\0';
	   2711 
	   2712   ierr = Build_FLIST();                /* Construct list of input files    */
	   2713   if (ierr != 0) exit(EXIT_FAILURE);
	   2714 
	   2715   for (ifile=0;ifile < FLISTne;ifile++) {
	   2716     if (ifile == 0) {
	   2717       ierr=Import_FFD();               /* Import infile description */
	   2718       if (ierr != 0) exit(EXIT_FAILURE);
	   2719       ierr = Determine_EpGenerator();  /* Find var which enables Epoch calc*/
	   2720       if (ierr != 0) exit(EXIT_FAILURE);
	   2721     }
	   2722     MSG_control(1," ",0); MSG_control(1,"----Beginning Translation----",0);
	   2723     ierr = Generate_CDFskeleton();     /* Generate the CDF skeleton.     */
	   2724     if (ierr != 0) exit(EXIT_FAILURE);
	   2725     ierr = Build_OLIST();              /* Build the ordered input list.  */
	   2726     if (ierr != 0) exit(EXIT_FAILURE);
	   2727     if (ifile == 0) { 

                                Source Listing                  11-SEP-1997 17:17:27    DEC C V4.0-000                      Page   2
                                                                11-JUN-1996 12:50:10    SMS1:[WIND.SOFTWARE.MAKECDF]MAKECDF.C;13

	   2728       ierr = Match_Variables();        /* Map input vars to CDF variables*/
	   2729       if (ierr != 0) exit(EXIT_FAILURE);
	   2730       ierr = Allocate_Buffers();       /* Allocate buffer space for vars.*/
	   2731       if (ierr != 0) exit(EXIT_FAILURE);
	   2732     }
	   2733     ierr = Open_Infile(ifile);         /* Open Input File and in-buffer. */
	   2734     if (ierr != 0) exit(EXIT_FAILURE);
	   2735     ierr = Open_OutCDF();              /* Open the output CDF file       */
	   2736     if (ierr != 0) exit(EXIT_FAILURE);
	   2737 
	   2738     OLidx=0;
	   2739     do {
	   2740       ierr=0;  vnum  = OLIST[OLidx].vnum;  velem = OLIST[OLidx].velem;
	   2741       if (vnum == -1) { /* time to read a new record from the input file */
	   2742         if (OLIST[OLidx].rflag == TRUE) Read_Infile();
	   2743         /* set rflag for this eol to false if in header section of file */
	   2744         pvnum = OLIST[OLidx-1].vnum;
	   2745         if (VLIST[pvnum].header == TRUE) OLIST[OLidx].rflag = FALSE;
	   2746       }
	   2747       else {
	   2748         if (OLIST[OLidx].rflag == TRUE) {
	   2749           if (INFILE.format == 0) icnt=Parser1(vnum,velem);  /* freeform  */
	   2750           else {                                             /* fixedform */
	   2751             if (INFILE.dtype == 0) icnt=Parser2(vnum,velem); /* text      */
	   2752             else icnt=Parser3(vnum,velem);                   /* binary    */
	   2753           }
	   2754         }
	   2755         if (icnt == 0) { Read_Infile(); OLidx=OLISTne+1; }
	   2756         else {
	   2757           if (OLIST[OLidx].pflag == TRUE) { /* process variable */
	   2758             if (vnum == EpALG.EpGenerator) {
	   2759               ierr = Generate_Epoch(&depoch);
	   2760               if (ierr == 0) { /* increment CDF rec# and write to CDF */
	   2761                 OUTCDF.CDFrec++;
	   2762                 ierr = WriteEpochToCDF(depoch,OUTCDF.CDFrec);
	   2763               }
	   2764             }
	   2765             else if ((VLIST[vnum].bsubr != 0)&&(velem == 0)) {
	   2766               /* first element of first variable in new subrecord */
	   2767               snum = VLIST[vnum].bsubr-1; /* get subrecord number */
	   2768               if (SRECS[snum].countr != 0) {   /* not first iteration */
	   2769                 if (SRECS[snum].delta > 0.0) { /* involved in time calcs */
	   2770                   depoch=depoch+((double)SRECS[snum].countr*SRECS[snum].delta);
	   2771                   OUTCDF.CDFrec++;
	   2772                   ierr = WriteEpochToCDF(depoch,OUTCDF.CDFrec);
	   2773                 }
	   2774               }
	   2775               SRECS[snum].countr++;
	   2776             }
	   2777             if ((VLIST[vnum].cdfvarnum>=0)&&(velem==VLIST[vnum].nelems-1)) {
	   2778               /* Perform data quality checking */
	   2779               if (VLIST[vnum].autofill > 0) iflag = AutoFiller(vnum);
	   2780               if (iflag == 0) { /* data is not filler - continue QA checks */
	   2781                 if ((VLIST[vnum].autovalids > 0)||
	   2782                     (VLIST[vnum].autoscales > 0)) ierr = AutoMinMax(vnum);
	   2783               }
	   2784               /* Write the data out to the CDF file */

                                Source Listing                  11-SEP-1997 17:17:27    DEC C V4.0-000                      Page   3
                                                                11-JUN-1996 12:50:10    SMS1:[WIND.SOFTWARE.MAKECDF]MAKECDF.C;13

	   2785               if (vnum < EpALG.EpGenerator) {
	   2786                 ierr = WriteToCDF(vnum,OUTCDF.CDFrec+1); }
	   2787               if (vnum >= EpALG.EpGenerator) {
	   2788                 ierr = WriteToCDF(vnum,OUTCDF.CDFrec);
	   2789               }
	   2790             }
	   2791           }
	   2792           if (VLIST[vnum].constant == TRUE) OLIST[OLidx].pflag = FALSE;
	   2793           if (VLIST[vnum].header == TRUE) OLIST[OLidx].rflag   = FALSE;
	   2794           if (VLIST[vnum].header == TRUE) OLIST[OLidx].pflag   = FALSE;
	   2795       } }
	   2796 
	   2797       OLidx = OLidx + 1;
	   2798       if (OLidx >= OLISTne) {
	   2799         OLidx=0; for (i=0;i<SRECSne;i++) SRECS[i].countr=0;
	   2800       }
	   2801     } while (!feof(INFILE.fptr));
	   2802 
	   2803     /* Set attribute values in CDF which were determined during Xlation   */
	   2804     ierr = Generate_LFILEID(lfileid); /* Determine ISTP formatted lfileid */
	   2805     if (ierr==0) ierr = Set_LFILEID(lfileid); /* Set ISTP lfileid gATTR   */
	   2806     ierr = Set_AutoVattrs(); /* optionally set min and max vATTRS*/
	   2807 
	   2808     /* Close the CDF, the input file, and deallocate memory */
	   2809     ierr = Cleanup_makeCDF(ifile);
	   2810     if (ierr == 0) {
	   2811       /* Rename the output CDF if auto-naming option is used */
	   2812 #if defined SHORTY
       X   2813       ierr = ShortName(lfileid);
       X   2814 #endif
	   2815       if (ierr == 0) ierr = AutoNamer(RPARMS.outcdfname,lfileid);
	   2816     }
	   2817 
	   2818     /* Close the logfile */
	   2819     if (LOGFILE.fptr != NULL) fclose(LOGFILE.fptr);
	   2820   }
	   2821   exit(EXIT_SUCCESS);
	   2822 }


Command Line
------- ----

CC /ANSI_ALIAS/ASSUME=(ACCURACY_SENSITIVE,ALIGNED_OBJECTS,NOWRITABLE_STRING_LITERALS)
/DEBUG=(TRACEBACK)/ENDIAN=LITTLE/EXTERN_MODEL=RELAXED_REFDEF/FLOAT=(G_FLOAT
)/GRANULARITY=QUADWORD/INSTRUCTION_SET=FLOATING_POINT/L_DOUBLE_SIZE=128
/LIST/NOMACHINE_CODE/MEMBER_ALIGNMENT/NAMES=UPPERCASE/NESTED_INCLUDE_DIRECTORY=INCLUDE_FILE
/NOOBJECT/OPTIMIZE=(LEVEL=4,UNROLL=0)/PREFIX=(ANSI_C89_ENTRIES)/PSECT_MODEL=NOMULTILANGUAGE
/ROUNDING_MODE=NEAREST/SHOW=(HEADER,SOURCE)/SIGNED_CHAR/STANDARD=RELAXED_ANSI89
/REENTRANCY=TOLERANT/WARNINGS
/INCLUDE=(CDF$INC:)
