WIND_L1_OPEN_NEXT                                               21-APR-1995 16:15:34    DEC Fortran V6.2-508                Page   1
                                                                13-MAR-1995 19:13:44    [WIND.SOFTWARE.L1]WIND_L1_OPEN_NEXT.FOR;18

	      1         SUBROUTINE WIND_L1_OPEN_NEXT(unit,mode,filename,file_header,status)
	      2  
	      3 C+
	      4 C 
	      5 C FUNCTIONAL DESCRIPTION:       
	      6 C
	      7 C    Open the next L1 file in sequence after the current L1 file.  The current
	      8 C    L1 file is indicated by the unit number passed in <unit>.  The current file
	      9 C    is closed and the new file is opened on the same unit number.
	     10 C
	     11 C FORMAL PARAMETERS:
	     12 C
	     13 C     unit:
	     14 C         An INTEGER*4 variable giving the Fortran unit on which the current L1
	     15 C         file is open.
	     16 C
	     17 C     mode:
	     18 C         The open mode to use.  The allowable values are given below:
	     19 C
	     20 C         Value     Meaning
	     21 C           1       Attempt to open the next file in sequence by incrementing
	     22 C                   the date (and possibly year) portion of the filename.  If
	     23 C                   the file does not exist return an error status.
	     24 C           2       Open the next file in sequence by incrementing the date (and
	     25 C                   possibly year) portion of the filename.  If the file does
	     26 C                   not exist keep incrementing the date until a file is found
	     27 C                   or MAX_ATTEMPT attempts have been made.
	     28 C
	     29 C     filename:
	     30 C         A CHARACTER variable which, upon return, will contain the name of the
	     31 C         L1 file which has been opened.  If the open failed filename will be
	     32 C         blank.
	     33 C
	     34 C     file_header:
	     35 C         A record of structure type ST_L1_FILE_HEADER.  Upon successful return
	     36 C         this will contain the file header of the newly opened file.
	     37 C
	     38 C     status:
	     39 C         An INTEGER*4 variable which, upon return, will contain the status of
	     40 C         the open next operation.  An 1 indicates success.
	     41 C
	     42 C  
	     43 C COMMON BLOCKS:
	     44 C  
	     45 C     L1READ	  holds headers, etc.
	     46 C  
	     47 C DESIGN:
	     48 C  
	     49 C     Use INQUIRE to find the current filename associated with the given unit,
	     50 C     then close the unit.  Decode the year, month, and day from the filename.
	     51 C     Calculate the next day's date and encode it into the filename again.  Open
	     52 C     the next file on the same unit number.  Use LIB$FIND_FILE routine to
	     53 C     search directory for first data set (lowest Vnn number) of that day to
	     54 C     handle case where only latest version is retained.
	     55 C
	     56 C     If the file does not exist and mode is 1, return with the status
	     57 C     WIND$_NONEXTFILE.  If mode is 2, keep incrementing the date (up to a

WIND_L1_OPEN_NEXT                                               21-APR-1995 16:15:34    DEC Fortran V6.2-508                Page   2
                                                                13-MAR-1995 19:13:44    [WIND.SOFTWARE.L1]WIND_L1_OPEN_NEXT.FOR;18

	     58 C     maximum of 10 days) and open to the first data set which does exist.
	     59 C  
	     60 C 
	     61 C This version:   1.2   13-MAR-1995
	     62 C 
	     63 C Created: 
	     64 C 
	     65 C        18-JAN-1995    Lawrence Bleau
	     66 C 
	     67 C Revised:
	     68 C 
	     69 C        Date     | Name  | Description
	     70 C ----------------+-------+-----------------------------------------------------
	     71 C 1.1 10-MAR-1995 |  LRB  | make use of WIND condition codes for errors, finish
	     72 C			    coding logic and testing
	     73 C 1.2 13-MAR-1995 |  LRB  | added call to lib$find_file to have program search
	     74 C                           for first data set of a given day (lowest Vnn
	     75 C			    number)
	     76 C 
	     77 C-
	     78 CDEC$   IDENT   '1.2'
	     79 
	     80         IMPLICIT NONE
	     81         INCLUDE '($SSDEF)/NOLIST'
	   1506         INCLUDE '($RMSDEF)/NOLIST'
	   2217         INCLUDE 'INC_DIR:EDBDEF.INC /NOLIST'

WIND_L1_OPEN_NEXT                                               21-APR-1995 16:15:34    DEC Fortran V6.2-508                Page   3
1.2                                                             13-MAR-1995 19:13:44    [WIND.SOFTWARE.L1]WIND_L1_OPEN_NEXT.FOR;18

	   2755         INCLUDE 'INC_DIR:L1FMT.INC /NOLIST'
	   2887         INCLUDE 'INC_DIR:L1READ.INC /NOLIST'
	   2939         INTEGER MAX_ATTEMPTS
	   2940         PARAMETER (MAX_ATTEMPTS = 10)
	   2941 C
	   2942         INTEGER unit,mode,status
	   2943         CHARACTER*(*) filename
	   2944         RECORD /ST_L1_FILE_HEADER/ file_header
	   2945 C
	   2946         INTEGER i,i2,pos,max_tries,count,year,month,day,file_format,nch,leap
	   2947         INTEGER num_days(12,2),patlen
	   2948 	INTEGER*4 lib$find_file,lib$find_file_end,context
	   2949         LOGICAL opened,found,there
	   2950         CHARACTER this_file*100,new_file*100,pattern*100
	   2951         DATA num_days/31,28,31,30,31,30,31,31,30,31,30,31,
	   2952      &                31,29,31,30,31,30,31,31,30,31,30,31/
	   2953 
	   2954         EXTERNAL WIND$_FILNOTOPN,WIND$_FILNAMFMT,WIND$_NONEXTFILE
	   2955 C
	   2956 C Get the full filename associated with the given unit.  Parse it to locate the
	   2957 C filename proper and where the date is located within the filename.  Finally,
	   2958 C close the original L1 file.
	   2959 C
	   2960         INQUIRE (UNIT = unit, OPENED = opened)
	   2961         IF (.not. opened) THEN
	   2962             status = %LOC(WIND$_FILNOTOPN)
	   2963             RETURN
	   2964         ENDIF
	   2965         INQUIRE (UNIT = unit, NAME = this_file)
	   2966         i = INDEX (this_file, ']') + 1
	   2967         i2 = INDEX (this_file(i:), '.') - 1
	   2968         CALL WIND_L1_CLOSE(unit, status)
	   2969         IF (status .ne. 1) RETURN
	   2970 C
	   2971 C Filename can be in one of two formats; check both and set pos to point to
	   2972 C start of year portion of date.
	   2973 C 
	   2974 C Format 1: WI_L1_SMS_yyyymmdd_Vvv.DAT
	   2975 C Format 2: yymmddvv.DAT
	   2976 
	   2977 C
	   2978         IF (this_file(i:i+4) .eq. 'WI_L1') THEN
	   2979             file_format = 1
	   2980             pos = i + 10
	   2981         ELSE
	   2982             file_format = 2
	   2983             pos = i
	   2984         END IF
	   2985 C
	   2986 C Convert month, day to integers
	   2987 C
	   2988         IF (file_format .eq. 1) THEN
	   2989             READ (this_file(pos:pos+7), 1001, ERR=900, IOSTAT=status)
	   2990      1        year,month,day
	   2991 1001        FORMAT(I4.4, I2.2, I2.2)
	   2992         ELSE
	   2993             READ (this_file(pos:pos+5), 1002, ERR=900, IOSTAT=status)

WIND_L1_OPEN_NEXT                                               21-APR-1995 16:15:34    DEC Fortran V6.2-508                Page   4
1.2                                                             13-MAR-1995 19:13:44    [WIND.SOFTWARE.L1]WIND_L1_OPEN_NEXT.FOR;18

	   2994      1        year,month,day
	   2995 1002        FORMAT(I2.2, I2.2, I2.2)
	   2996         END IF
	   2997 C
	   2998 C Set up loop by getting a copy of the original filename, setting the maximum
	   2999 C number of times to go around the loop, and setting the file-found flag to
	   3000 C false.
	   3001 C Go into loop, looking for next filename in sequence.  First compute new date,
	   3002 C then construct new filename, and finally use INQUIRE to check if the file
	   3003 C exists.  If it does we can exit the loop; if not we go around again.
	   3004 C When constructing new filename replace the year, month, and day of month. 
	   3005 C Also reset the data set version to '01' just in case the previous file was a
	   3006 C higher data set version.  There is no current mechanism to handle accessing
	   3007 C later data set versions.
	   3008 C
	   3009 C If mode=1 we go through loop only once; if file for next date isn't there we
	   3010 C quit.  If mode=2 we keep trying, up to a reasonable maximum number of times.
	   3011 C
	   3012         pattern = this_file
	   3013         patlen = INDEX (pattern, ';')
	   3014         IF (patlen .ne. 0) pattern(patlen:) = ' '
	   3015         patlen = INDEX (pattern, ' ') - 1
	   3016         max_tries = 1
	   3017         IF (mode .eq. 2) max_tries = MAX_ATTEMPTS
	   3018         count = 1
	   3019         found = .FALSE.
	   3020         leap = 1
	   3021         IF (MOD(year,4) .eq. 0 .and. MOD(year,100) .ne. 0) leap = 2
	   3022 C
	   3023         DO WHILE (count .le. max_tries .and. .not. found)
	   3024             day = day + 1
	   3025             IF (day .gt. num_days(month,leap)) THEN
	   3026                 month = month + 1
	   3027                 day = 1
	   3028                 IF (month .gt. 12) THEN
	   3029                     year = year + 1
	   3030                     leap = 1
	   3031                     IF (MOD(year,4) .eq. 0 .and. MOD(year,100) .ne. 0) leap = 2
	   3032                     month = 1
	   3033                 END IF
	   3034             END IF
	   3035             IF (file_format .eq. 1) THEN
	   3036                 WRITE (pattern(pos:pos+7), 1001) year,month,day
	   3037                 pattern(pos+10:pos+11) = '%%'
	   3038             ELSE
	   3039                 WRITE (pattern(pos:pos+5), 1002) MOD(year,100),month,day
	   3040                 pattern(pos+6:pos+7) = '%%'
	   3041             END IF
	   3042 C
	   3043 C Now search for the filename, matching the lowest data set version (Vnn)
	   3044 C If we found it get its length and set found to true
	   3045 C If we didn't find it this day's data set is missing, set found to false
	   3046 C
	   3047 	    context = 0
	   3048       	    status = lib$find_file (pattern(1:patlen), new_file, context, , , ,)
	   3049 	    IF (status .eq. RMS$_NORMAL) THEN	    ! we found a file
	   3050 		nch = INDEX( new_file, ' ' ) - 1    ! get filename's length

WIND_L1_OPEN_NEXT                                               21-APR-1995 16:15:34    DEC Fortran V6.2-508                Page   5
1.2                                                             13-MAR-1995 19:13:44    [WIND.SOFTWARE.L1]WIND_L1_OPEN_NEXT.FOR;18

	   3051       	        INQUIRE (FILE = new_file(1:nch), EXIST = found)
	   3052       	    ELSE			      	    ! not found,
	   3053 		found = .false.			    ! st flag accordingly
	   3054 	    END IF
	   3055 	    status = lib$find_file_end (context)
	   3056             count = count + 1
	   3057         END DO
	   3058 C
	   3059 C Done with loop.  We either have a file we can open (found is true) or we ran
	   3060 C out of possibilities (found=false).  If found open it and return filename to
	   3061 C caller, otherwise return blank filename and an error status.
	   3062 C
	   3063         IF (found) THEN
	   3064             CALL WIND_L1_OPEN(unit, new_file(1:nch), file_header, status)
	   3065         ELSE
	   3066             status = %LOC(WIND$_NONEXTFILE)
	   3067         END IF
	   3068         IF (IAND(status,1) .eq. 1 .or. IAND(status,7) .eq. 0) THEN
	   3069             filename = new_file(1:nch)
	   3070         ELSE
	   3071             filename = ' '
	   3072         END IF
	   3073         RETURN
	   3074 C
	   3075 C Error handling code
	   3076 C
	   3077 900     filename = ' '
	   3078         status = %LOC(WIND$_FILNAMFMT)
	   3079         RETURN
	   3080         END

WIND_L1_OPEN_NEXT                                               21-APR-1995 16:15:34    DEC Fortran V6.2-508                Page   6
1.2                             Symbol Table                    13-MAR-1995 19:13:44    [WIND.SOFTWARE.L1]WIND_L1_OPEN_NEXT.FOR;18



PROGRAM SECTIONS

    Name				 Bytes   Attributes

  1 $DATA$                                  96 NOPIC CON REL LCL NOSHR NOEXE   RD   WRT OCTA
  2 $BSS$                                  336 NOPIC CON REL LCL NOSHR NOEXE   RD   WRT OCTA
  3 $IODATA$                                40 NOPIC CON REL LCL NOSHR NOEXE   RD   WRT OCTA
  4 $CODE$                                3008   PIC CON REL LCL   SHR   EXE NORD NOWRT OCTA
  5 $LINK$                                 438 NOPIC CON REL LCL NOSHR NOEXE   RD NOWRT OCTA
  6 L1_HEADERS                             644 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
  7 L1INFO                             3044160 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
  8 L1INFO2                              13042 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
  9 L1BUF                                65534 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 10 NULLBUF                              65536 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA

    Total Space Allocated              3192834


ENTRY POINTS

    Address   Type  Name             
                                     
  4-00000000        WIND_L1_OPEN_NEXT


VARIABLES

    Address   Type  Name            Address   Type  Name            Address   Type  Name            Address   Type  Name       
                                                                                                                               
  9-00000000  CHAR  BUFFER      REG-0000000B  I*4   I             2-0000000C  I*4   NCH               **      I*4   STATUS     
  0-0000006C  I*4   CONTEXT           **      I*4   I2            2-00000080  CHAR  NEW_FILE      2-00000014  L*4   THERE      
REG-0000000E  I*4   COUNT       REG-0000000F  I*4   LEAP         10-00000000  CHAR  NULL_BUFFER   2-00000018  CHAR  THIS_FILE  
  2-00000008  I*4   DAY           0-00000040  I*4   MAX_TRIES     2-00000010  L*4   OPENED            **      I*4   UNIT       
      **      CHAR  FILENAME      8-000000A0  CHAR  MAX_VERSION REG-########  I*4   PATLEN        2-00000000  I*4   YEAR       
  0-00000068  I*4   FILE_FORMAT       **      I*4   MODE          2-000000E8  CHAR  PATTERN                                    
  0-00000044  L*4   FOUND         2-00000004  I*4   MONTH       REG-0000000C  I*4   POS                                        


RECORDS

    Address   Name            Structure                Bytes     Address   Name            Structure                Bytes
                                                                                                                         
      **      FILE_HEADER     ST_L1_FILE_HEADER          400   6-00000190  L1_SR_HEADER    ST_L1_SR_HEADER            244
  6-00000000  L1_FILE_HEADER  ST_L1_FILE_HEADER          400                                                             



WIND_L1_OPEN_NEXT                                               21-APR-1995 16:15:34    DEC Fortran V6.2-508                Page   7
1.2                             Symbol Table                    13-MAR-1995 19:13:44    [WIND.SOFTWARE.L1]WIND_L1_OPEN_NEXT.FOR;18

ARRAYS

     Address  Type  Name                   Bytes  Dimensions

  8-00000000  I*4   L1_UNITS                  80  (20)
 10-00000000  I*1   NULL_BYTE_ARRAY        65534  (65534)
 10-00000000  I*4   NULL_I4_ARRAY          65536  (16384)
  1-00000000  I*4   NUM_DAYS                  96  (12, 2)
  8-00000050  I*4   SCIRECNUM                 80  (20)



RECORD ARRAYS

    Address   Name               Structure                 Bytes  Dimensions

  7-002E0400  L1_HDB             HDBSTR                    6480  (20)
  8-000000A2  L1_HEADER          ST_L1_FILE_HEADER         8000  (20)
  7-002E1D50  L1_HKEEP           HKEEP                    22000  (20)
  7-001FFD60  L1_MASS_PHA        MA_PHA                  919200  (20)
  7-001F6760  L1_MASS_RATE       MA_RATE                  38400  (20)
  7-00000000  L1_SCI             CORE                    147680  (20)
  8-00001FE2  L1_SCI_REC_HEADER  ST_L1_SR_HEADER           4880  (20)
  7-001432A0  L1_STICS_PHA       ST_PHA                  734400  (20)
  7-0010D420  L1_STICS_RATE      ST_RATE                 220800  (20)
  7-00047360  L1_SWICS_PHA       SW_PHA                  811200  (20)
  7-000240E0  L1_SWICS_RATE      SW_RATE                 144000  (20)



LABELS

    Address   Label     Address   Label     Address   Label
                                                           
  4-000009F8   900        **       1001       **       1002


FUNCTIONS AND SUBROUTINES REFERENCED

  Type  Name                      Type  Name                      Type  Name                      Type  Name                   
                                                                                                                               
  I*4   LIB$FIND_FILE                   WIND$_FILNAMFMT                 WIND$_NONEXTFILE                WIND_L1_OPEN           
  I*4   LIB$FIND_FILE_END               WIND$_FILNOTOPN                 WIND_L1_CLOSE                                          

WIND_L1_OPEN_NEXT                                               21-APR-1995 16:15:34    DEC Fortran V6.2-508                Page   8
1.2                             Symbol Table                    13-MAR-1995 19:13:44    [WIND.SOFTWARE.L1]WIND_L1_OPEN_NEXT.FOR;18



  +---------------------------------------------------+
  |               KEY TO ADDRESS CODE FORMATS         |
  |   ppp-oooooooo  - In Psect ppp, Offset oooooooo   |
  |   ***-********  - External                        |
  |               # - Suffix: Also In Registers       |
  |   REG-rrrrrrrr  - In Register rrrrrrrr            |
  |   REG-########  - In Various Registers            |
  |        **       - Not Used; Not Allocated         |
  +---------------------------------------------------+


COMMAND QUALIFIERS

  /ALIGNMENT=(COMMONS=(PACKED,NOMULTILANGUAGE),RECORDS=PACKED)
  /ASSUME=(ACCURACY_SENSITIVE,BACKSLASH,NODUMMY_ALIASES,NOUNDERSCORE)
  /CHECK=(ASSERTIONS,BOUNDS,FORMAT,FP_EXCEPTIONS,OVERFLOW,ÿÿÿ°&¶
  /DEBUG=(NOSYMBOLS,TRACEBACK)
  /DESIGN=(NOCOMMENTS)
  /SHOW=(DICTIONARY,INCLUDE,MAP,PREPROCESSOR)
  /STANDARD=(NOSEMANTIC,NOSOURCE_FORM,NOSYNTAX)
  /WARNINGS=(NOALIGNMENT,NOARGUMENT_CHECKING,DECLARATIONS,GENERAL,NOTRUNCATED_SOURCE,UNCALLED,
             UNINITIALIZED,UNREACHABLE,UNUSED)
  /NOAUTOMATIC  /BLAS=NOMAPPED  /CONVERT=NATIVE  /NOCROSS_REFERENCE  /NOD_LINES  /ERROR_LIMIT=30  /EXTEND_SOURCE
  /NOPAD_SOURCE  /NOF77  /FLOAT=G_FLOAT  /IEEE_MODE=FAST  /ROUNDING_MODE=NEAREST
  /GRANULARITY=QUADWORD  /INSTRUCTION_SET=FLOATING  /INTEGER_SIZE=32  /NOMACHINE_CODE
  /MATH_LIBRARY=ACCURATE  /NAMES=UPPERCASE  /OPTIMIZE=(LEVEL=4,UNROLL=0)  /REAL_SIZE=32  /NORECURSIVE
  /NOSEPARATE_COMPILATION  /NOSYNCHRONOUS_EXCEPTIONS  /NOSYNTAX_ONLY  /TERMINAL=NOSTATISTICS  /NOTIE  /VMS
  /NOANALYSIS_DATA
  /NODIAGNOSTICS
  /INCLUDE=(.FOR,.f,FORT$INCLUDE:.FOR,FORT$INCLUDE:.f)
  /LIST=SMS1:[WIND.SOFTWARE.L1]WIND_L1_OPEN_NEXT.LIS;10
  /OBJECT=SMS1:[WIND.SOFTWARE.L1]WIND_L1_OPEN_NEXT.OBJ;13
  /NOLIBRARY
   sys$lib=SYS$COMMON:[SYSLIB]FORSYSDEF.TLB;1

COMPILER: DEC Fortran V6.2-508-274F

COMPILATION STATISTICS

  CPU time:          1.89 seconds
  Elapsed time:      7.36 seconds
  Pagefaults:         335
  I/O Count:           33
