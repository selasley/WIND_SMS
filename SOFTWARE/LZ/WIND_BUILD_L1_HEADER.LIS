WIND_BUILD_FILE_HEADER                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page   1
                                                                26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

	      1         SUBROUTINE WIND_BUILD_FILE_HEADER
	      2 C+
	      3 C 
	      4 C FUNCTIONAL DESCRIPTION:       
	      5 C 
	      6 C  This subroutine fills in the various fields of the Level 1 file header with
	      7 C  data which was stored by the main program in preparation for it being
	      8 C  written to disk.
	      9 C
	     10 C FORMAL PARAMETERS:
	     11 C  
	     12 C   None
	     13 C  
	     14 C COMMON BLOCKS:
	     15 C  
	     16 C   FILE        contains name of input and output files
	     17 C   L1_HEADERS  contains L1 header structures
	     18 C  
	     19 C DESIGN:
	     20 C  
	     21 C   Access the various COMMON blocks maintained by WIND_CD_READ to obtain the
	     22 C   needed information.  Use system calls to get the remaining information.
	     23 C
	     24 C   The comment field can have two sources: a program-generated value and a
	     25 C   user-specified value.  The user can specify a value by defining the logical
	     26 C   name WIND_COMMENT before running the program.  WIND_CD_READ can also store
	     27 C   a comment directly in the file header structure.  The user comment is thus
	     28 C   overwritten and superceded if WIND_CD_READ stores anything there.  The
	     29 C   length of the comment field is computed by WIND_BUILD_FILE_HEADER. 
	     30 C
	     31 C This version:   1.16   12-APR-1995
	     32 C 
	     33 C Created: 
	     34 C 
	     35 C      14-OCT-1994    Larry Bleau
	     36 C 
	     37 C Revised:
	     38 C 
	     39 C Ver      Date       | Name  | Description
	     40 C --------------------+------------+------------------------------------------------
	     41 C 1.1	18-OCT-1994   |  JP   | Replaced version number with Creation Date of
	     42 C			        .EXE file 
	     43 C 1.2	 8-NOV-1994   |  LRB  | added system call to fill in architecture type
	     44 C 1.3	10-NOV-1994   |  LRB  | added system call to fill in medium field
	     45 C 1.4	 5-DEC-1994   |  LRB  | changed header version to '02' to reflect new
	     46 C			        /CORE/ definition
	     47 C 1.5	13-DEC-1994   |  LRB  | changed header version to '03' to reflect new
	     48 C			        /HKeep/ definition
	     49 C 1.6	15-DEC-1994   |  LRB  | filled in new file header fields, changed
	     50 C			        header version to '04'
	     51 C 1.7	 6-FEB-1995   |  LRB  | changed header version to '05' to reflect new
	     52 C			        fields in sci rec hdr
	     53 C 1.10	15-FEB-1995   |  LRB  | corrected code to put ending time into header
	     54 C 1.11	 8-MAR-1995   |  LRB  | copy LINK_DATE_TIME to date_of_EXE field in
	     55 C			        file header; add program_vers field to file
	     56 C			        header, did not update header version
	     57 C 1.13	15-MAR-1995   |  LRB  | change names of vars in common block DATES

WIND_BUILD_FILE_HEADER                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page   2
                                                                26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

	     58 C 1.15	10-APR-1995   |  LRB  | added field eph_avail to file header
	     59 C 1.16	12-APR-1995   |  LRB  | removed LIB$GET_DVI system call, access FROM_CD
	     60 C				flag instead; add include L1INFO.INC
	     61 C-
	     62 CDEC$   IDENT   '1.16'
	     63 
	     64         IMPLICIT NONE
	     65         INCLUDE 'INC_DIR:EDBDEF.INC/NOLIST'

WIND_BUILD_FILE_HEADER                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page   3
1.16                                                            26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

	    603         INCLUDE 'INC_DIR:EDBVARS.INC/NOLIST'

WIND_BUILD_FILE_HEADER                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page   4
1.16                                                            26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

	    785         INCLUDE 'INC_DIR:L1FMT.INC/NOLIST'
	    917         INCLUDE 'INC_DIR:DIAG.INC/NOLIST'
	    926         INCLUDE 'INC_DIR:L1INFO.INC/NOLIST'
	    954         INCLUDE '($SYIDEF)/NOLIST'
	   1460 	INCLUDE '($DVIDEF)/NOLIST'
	   1718 C
	   1719         INTEGER year,hrs,mins,secs,month,day,pos
	   1720         INTEGER*4 nch,doy
	   1721         CHARACTER date1*9,date_str*11,ascii_date*23
	   1722         CHARACTER*80 lz_filename, l1_filename
	   1723         CHARACTER arch_name*15,media_name*10
	   1724         INTEGER*4 Clock_Beg_Year, Clock_Beg_DOY, Clock_Beg_Msec, Clock_Beg_MicSec
	   1725         INTEGER*4 Clock_End_Year, Clock_End_DOY, Clock_End_Msec, Clock_End_MicSec
	   1726 C
	   1727         COMMON /FILE/ lz_filename, l1_filename
	   1728 	COMMON /DATES/ Clock_Beg_Year, Clock_Beg_DOY, Clock_Beg_Msec, Clock_Beg_MicSec,
	   1729      &                 Clock_End_Year, Clock_End_DOY, Clock_End_Msec, Clock_End_MicSec
	   1730 C
	   1731 C Start by filling in the ident field (always the constant 'HDRF') and the
	   1732 C header version number
	   1733 C
	   1734         l1_file_header.ident = 'HDRF'
	   1735         l1_file_header.header_vers = '06'
	   1736 C
	   1737 C Compute length of comment field and store it in comment_len field
	   1738 C A length of zero indicates there was no comment
	   1739 C
	   1740         nch = LEN(l1_file_header.comment)
	   1741         DO WHILE (nch .ge. 1)
	   1742           IF (l1_file_header.comment(nch:nch) .ne. ' ') GOTO 110
	   1743           nch = nch - 1
	   1744         END DO
	   1745 110	WRITE(l1_file_header.comment_len, 111) nch
	   1746 111	FORMAT(i3)
	   1747 C
	   1748 C Get today's date and fill in the run_date field
	   1749 C Adjust year for current century
	   1750 C
	   1751         CALL date (date1)
	   1752         READ(date1(8:9), 112) year
	   1753 112	FORMAT(i2)
	   1754         IF (year .lt. 90) THEN
	   1755           year = 2000 + year
	   1756         ELSE
	   1757           year = year + 1900
	   1758         END IF
	   1759         WRITE(l1_file_header.run_date, 113) date1(1:7),year
	   1760 113	FORMAT(a7,i4)
	   1761 C
	   1762 C Get input filename and save in header
	   1763 C
	   1764         l1_file_header.input_file = lz_filename
	   1765 C
	   1766 C Set medium code in header: 'CD' = CDROM, 'DK' = magnetic disk
	   1767 C
	   1768         l1_file_header.medium = '  '
	   1769 	IF (from_cd) THEN

WIND_BUILD_FILE_HEADER                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page   5
1.16                                                            26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

	   1770 	  l1_file_header.medium = 'CD'
	   1771 	ELSE
	   1772 	  l1_file_header.medium = 'DK'
	   1773 	ENDIF
	   1774 C
	   1775 C Get system hardware (architecture) type and save it
	   1776 C Currently only types are 'VAX' and 'Alpha', so saving first letter is enough
	   1777 C
	   1778         arch_name(1:1) = ' '		      ! just in case it fails
	   1779 	CALL lib$getsyi (
	   1780 	1	 syi$_arch_name,, 
	   1781 	1	 arch_name, 
	   1782 	1	 nch,,) 
	   1783         l1_file_header.hw_type = arch_name(1:1)
	   1784 C
	   1785 C Fill in start and stop times
	   1786 C
	   1787 	CALL doy_to_month_day( Clock_Beg_Year, Clock_Beg_DOY, month, day, date_str )
	   1788 	hrs = Clock_Beg_Msec/(60*60*1000)
	   1789 	mins = Clock_Beg_Msec/(60*1000) - hrs*60
	   1790 	secs = Clock_Beg_Msec/1000 - (hrs*60+mins)*60
	   1791         write(l1_file_header.start_time, 1001) date_str, hrs, mins, secs
	   1792 C
	   1793 	CALL doy_to_month_day( Clock_End_Year, Clock_End_DOY, month, day, date_str )
	   1794 	hrs = Clock_End_Msec/(60*60*1000)
	   1795 	mins = Clock_End_Msec/(60*1000) - hrs*60
	   1796 	secs = Clock_End_Msec/1000 - (hrs*60+mins)*60
	   1797         write(l1_file_header.stop_time, 1001) date_str, hrs, mins, secs
	   1798 C
	   1799 C Save time this program was linked
	   1800 C Also save program's version number
	   1801 C
	   1802 	l1_file_header.date_of_EXE = link_date_time
	   1803 	l1_file_header.program_vers = prog_version
	   1804 C
	   1805 C Save creation date of LZ file
	   1806 C
	   1807 	CALL GET_CDT(lz_filename,ascii_date,doy)
	   1808 	WRITE(l1_file_header.credate_doy, 1005) doy
	   1809 	l1_file_header.credate_year = ascii_date(8:11)
	   1810 	l1_file_header.credate = ascii_date(1:11)
	   1811 C
	   1812 C Save number of L1 records written, number of good EDBs processed, number of
	   1813 C EDBs lost, and number of EDBs skipped
	   1814 C
	   1815         WRITE(l1_file_header.L1_records, 1003) MIN(L1_recs_written,99999)
	   1816         WRITE(l1_file_header.EDB_count, 1004) MIN(EDB_Sum,999999)
	   1817         WRITE(l1_file_header.EDB_lost, 1004) MIN(EDB_Lost,999999)
	   1818         WRITE(l1_file_header.EDB_skip, 1004) MIN(EDB_Skip,999999)
	   1819 C
	   1820 1001	FORMAT(A11,1H ,I2.2,1H:,I2.2,1H:,I2.2)
	   1821 1002    FORMAT(I4,1H ,I3.3,1H.,I8.8,I4.4)
	   1822 1003    FORMAT(I4)
	   1823 1004    FORMAT(I6)
	   1824 1005	FORMAT(I3)
	   1825 C
	   1826 C If ephemeris and attitude information is available set eph_avail field in the

WIND_BUILD_FILE_HEADER                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page   6
1.16                                                            26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

	   1827 C file header to 'T'; otherwise set it to 'F'.
	   1828 C
	   1829 	IF (eph_avail) THEN
	   1830 	  l1_file_header.eph_avail = 'T'
	   1831 	ELSE
	   1832 	  l1_file_header.eph_avail = 'F'
	   1833 	ENDIF
	   1834 C
	   1835         RETURN
	   1836         END


PROGRAM SECTIONS

    Name				 Bytes   Attributes

  1 $DATA$                                 200 NOPIC CON REL LCL NOSHR NOEXE   RD   WRT OCTA
  2 $BSS$                                  600 NOPIC CON REL LCL NOSHR NOEXE   RD   WRT OCTA
  3 $IODATA$                               200 NOPIC CON REL LCL NOSHR NOEXE   RD   WRT OCTA
  4 $CODE$                                6312   PIC CON REL LCL   SHR   EXE NORD NOWRT OCTA
  5 $LINK$                                 840 NOPIC CON REL LCL NOSHR NOEXE   RD NOWRT OCTA
  6 EDB                                 454336 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
  7 EDB_HEADER                              20 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
  8 HDB                                    996 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
  9 HK                                    3912 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 10 L1_HEADERS                             644 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 11 DIAG                                    48 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 12 L1INFO                                  40 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 13 FILE                                   160 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 14 DATES                                   32 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 15 EPHDATA                              29384 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 16 GETDATEINFO                             60 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA

    Total Space Allocated               497784


ENTRY POINTS

    Address   Type  Name                  
                                          
  4-00000000        WIND_BUILD_FILE_HEADER


VARIABLES

    Address   Type  Name                    Address   Type  Name                    Address   Type  Name               
                                                                                                                       
  2-00000200  CHAR  ARCH_NAME            14-00000018  I*4   CLOCK_END_MSEC        1-000000B0  I*4   EDB_CORE_SIZE      
      **      CHAR  ASCII_DATE           14-00000010  I*4   CLOCK_END_YEAR       12-00000008  I*4   EDB_LOST           
  2-000001E8  CHAR  ASCII_DATE           12-00000014  I*4   CURR_SCI_REC_NUMBER  12-0000000C  I*4   EDB_SKIP           
  7-00000006  L*1   BITRATE              12-00000018  I*4   CURR_SPIN            12-00000010  I*4   EDB_SUM            
 14-00000004  I*4   CLOCK_BEG_DOY         2-00000228  CHAR  DATE1                12-00000020  L*4   EPH_AVAIL          
 14-0000000C  I*4   CLOCK_BEG_MICSEC      2-00000238  CHAR  DATE_STR                  **      CHAR  FILENAME           
 14-00000008  I*4   CLOCK_BEG_MSEC        2-00000220  I*4   DAY                  12-00000024  L*4   FROM_CD            
 14-00000000  I*4   CLOCK_BEG_YEAR       11-00000000  I*4   DIAG                 11-0000002C  L*4   HALT_IF_NO_EPH     
 14-00000014  I*4   CLOCK_END_DOY         0-00000044  I*4   DOY                   7-00000005  L*1   HDBFLAG            
 14-0000001C  I*4   CLOCK_END_MICSEC      6-0006EEBC  I*4   EDBSET                0-00000040# I*4   HRS                

WIND_BUILD_FILE_HEADER                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page   7
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

    Address   Type  Name                    Address   Type  Name                    Address   Type  Name               
                                                                                                                       
 11-00000004  L*4   INTER                 0-00000038# I*4   NCH                   7-00000009  L*1   STICSPOWER         
 13-00000050  CHAR  L1_FILENAME          12-0000001C  L*4   NEW_SCI_REC           1-000000B8  I*4   STICS_H_RATE_SIZE  
 12-00000004  I*4   L1_RECS_WRITTEN      11-00000008  L*4   NRT_MODE              1-000000BC  I*4   STICS_N_RATE_SIZE  
 11-00000010  CHAR  LINK_DATE_TIME        2-00000224  I*4   POS                   2-00000210  I*4   STICS_RATE_SIZE    
 13-00000000  CHAR  LZ_FILENAME          11-0000000C  L*4   PRINTLZ_MODE          7-00000004  L*1   SUBS_ID            
  7-00000008  L*1   MASSPOWER            11-00000027  CHAR  PROG_VERSION          7-00000007  L*1   SWICSPOWER         
  1-000000B4  I*4   MASS_RATE_SIZE        7-0000000A  L*1   RAMCHECK              1-000000C0  I*4   SWICS_H_RATE_SIZE  
  7-0000000C  I*4   MEASSPIN             12-00000000  I*4   SCI_REC_CNTR          1-000000C4  I*4   SWICS_N_RATE_SIZE  
  2-00000248  CHAR  MEDIA_NAME            0-00000044  I*4   SECS                  2-00000214  I*4   SWICS_RATE_SIZE    
  0-0000003C# I*4   MINS                  7-00000000  I*4   SFPERBLOCK            2-00000218# I*4   YEAR               
  2-0000021C  I*4   MONTH                 7-00000010  I*4   SPINCOUNT                                                  


RECORDS

    Address   Name            Structure                Bytes
                                                            
 10-00000000  L1_FILE_HEADER  ST_L1_FILE_HEADER          400
 10-00000190  L1_SR_HEADER    ST_L1_SR_HEADER            244


ARRAYS

     Address  Type  Name             Bytes  Dimensions

  6-00005688  I*1   CORE_DATA         1980  (0:10, 0:59, 3)
  8-000003CC  I*4   HDBTIME2            24  (2, 3)
  9-00000CF0  I*4   HKLOCI             300  (75)
  9-00000E1C  I*4   HKLOCJ             300  (75)
  9-00000CE4  I*4   HKSET               12  (3)
  7-0000000B  L*1   SPARFLAGS            1  (1)



RECORD ARRAYS

    Address   Name        Structure         Bytes  Dimensions

  8-00000000  HDB         HDBSTR             972  (3)
  9-00000000  HKEEP       HKEEP             3300  (3)
  6-0004D424  MASS_PHA    MA_PHA          137880  (3)
  6-0004BDA4  MASS_RATE   MA_RATE           5760  (3)
  6-00000000  SCI         CORE             22152  (3)
  6-00030F54  STICS_PHA   ST_PHA          110160  (3)
  6-00028DF4  STICS_RATE  ST_RATE          33120  (3)
  6-0000B2A4  SWICS_PHA   SW_PHA          121680  (3)
  6-00005E44  SWICS_RATE  SW_RATE          21600  (3)




WIND_BUILD_FILE_HEADER                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page   8
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

LABELS

    Address   Label     Address   Label     Address   Label     Address   Label     Address   Label
                                                                                                   
  4-0000019C   110        **       112        **       1001       **       1003       **       1005
      **       111        **       113        **       1002       **       1004                    


FUNCTIONS AND SUBROUTINES REFERENCED

  Type  Name                     Type  Name                     Type  Name                  
                                                                                            
        DOY_TO_MONTH_DAY               GET_CDT                        LIB$GETSYI            

WIND_BUILD_FILE_HEADER                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page   9
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

	   1838 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
	   1839         SUBROUTINE WIND_BUILD_SR_HEADER
	   1840 C+
	   1841 C 
	   1842 C FUNCTIONAL DESCRIPTION:       
	   1843 C 
	   1844 C  This subroutine fills in the various fields of the Level 1 Science Record
	   1845 C  header in preparation for it being written to disk.
	   1846 C 
	   1847 C FORMAL PARAMETERS:
	   1848 C  
	   1849 C   None
	   1850 C  
	   1851 C COMMON BLOCKS:
	   1852 C  
	   1853 C   See EDBVARS.INC, L1_HDR_INFO.INC
	   1854 C  
	   1855 C DESIGN:
	   1856 C  
	   1857 C     Instead of having a long parameter list, information will be gathered from
	   1858 C     various common blocks which contain the science record.  Only info on the
	   1859 C     first science record (the SCI(1) structure and its partners HDB(1) and
	   1860 C     HKeep(1)).
	   1861 C  
	   1862 C This version:  1.16    10-APR-1995
	   1863 C 
	   1864 C Created: 
	   1865 C 
	   1866 C      18-OCT-1994    Larry Bleau
	   1867 C 
	   1868 C Revised:
	   1869 C 
	   1870 C        Date       |     Name    | Description
	   1871 C ------------------+-------------+-----------------------------------------------------
	   1872 C      18-OCT-1994  | J.PAQUETTE  | Corrected use of IBSET
	   1873 C       2-NOV-1994  | L. Bleau    | added sci rec counter (from HDB) to header
	   1874 C 1.7  10-JAN-1995  | L. Bleau    | added statement to always fill in ident
	   1875 C                                 | field of SR header
	   1876 C 1.8   6-FEB-1995  | L. Bleau    | add code to scan for zero PHA words in each
	   1877 C                                 | spin and set a sensor-specific flag if there
	   1878 C                                 | are any 
	   1879 C 1.9  14-FEB-1995  | L. Bleau    | correct code which scanned for zero MASS PHA
	   1880 C                       	    words
	   1881 C 1.10  6-APR-1995  | J. Paquette | added code in preparation to including
	   1882 C                                   ephemeris data in record header
	   1883 C       7-APR-1995  | L. Bleau    | added include stmt for L1_HDR_INFO.INC
	   1884 C 1.15 10-APR-1995  | L. Bleau    | added code to transfer orbit info into
	   1885 C				    header 
	   1886 C 1.16 12-APR-1995  | L. Bleau    | add include L1INFO.INC
	   1887 C 
	   1888 C-
	   1889       IMPLICIT NONE
	   1890       INCLUDE 'INC_DIR:EDBDEF.INC/NOLIST'

WIND_BUILD_SR_HEADER                                             1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  10
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

	   2428       INCLUDE 'INC_DIR:EDBVARS.INC/NOLIST'

WIND_BUILD_SR_HEADER                                             1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  11
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

	   2610       INCLUDE 'INC_DIR:L1FMT.INC/NOLIST'
	   2742       INCLUDE 'INC_DIR:L1_HDR_INFO.INC/NOLIST'
	   2781       INCLUDE 'INC_DIR:L1INFO.INC/NOLIST'
	   2809       INTEGER*4 SPIN,TEMP,SRCOUNT,ZERO_COUNT,WHERE(100),FIRST_VALID,EPH_INDEX/1/
	   2810       INTEGER*4 MAX_EPH_INDEX/144/
	   2811       LOGICAL*1 LOG_VAR
	   2812       BYTE BYTE_VAR
	   2813       EQUIVALENCE (LOG_VAR,BYTE_VAR)
	   2814 C
	   2815       L1_SR_HEADER.IDENT = 'HDRR'
	   2816       L1_SR_HEADER.NVALID = 0
	   2817       L1_SR_HEADER.PRESENT(1) = 0
	   2818       L1_SR_HEADER.PRESENT(2) = 0
	   2819       L1_SR_HEADER.BITRATE_CODE = 0
	   2820       L1_SR_HEADER.ZERO_SWICS_PHA(1) = 0
	   2821       L1_SR_HEADER.ZERO_SWICS_PHA(2) = 0
	   2822       L1_SR_HEADER.ZERO_MASS_PHA(1) = 0
	   2823       L1_SR_HEADER.ZERO_MASS_PHA(2) = 0
	   2824       L1_SR_HEADER.ZERO_STICS_PHA(1) = 0
	   2825       L1_SR_HEADER.ZERO_STICS_PHA(2) = 0
	   2826 C
	   2827 C Scan through spins and do the following:
	   2828 C 1) count number of valid spins (qual flag zero)
	   2829 C 2) if a spin is present set corresponding bit in present bit array
	   2830 C 3) note if low, high, or mixed bitrate
	   2831 C 4) set flag in sensor-specific bit array if any of its PHA words are zero
	   2832 C 5) find first valid spin for use in time comparison below
	   2833       FIRST_VALID = -1
	   2834       DO 100 SPIN=0,59
	   2835         LOG_VAR = SCI(1).EDB(SPIN).QUAL
	   2836         IF (BYTE_VAR .EQ. 0) THEN                     ! valid spin?
	   2837 C
	   2838 C Count number of valid spins.
	   2839 C
	   2840           L1_SR_HEADER.NVALID = L1_SR_HEADER.NVALID + 1
	   2841 C
	   2842 C Set presence flag for this spin.
	   2843 C
	   2844           L1_SR_HEADER.PRESENT(SPIN/32+1) = IBSET( L1_SR_HEADER.PRESENT(SPIN/32+1), MOD(SPIN,32) )
	   2845 C
	   2846 C Set bit rate code for Science Record. If ALL spins in SCI-REC are at high bit
	   2847 C rate, L1_SR_HEADER.BITRATE_CODE is 2; if ALL spins in SCI-REC were at low bit
	   2848 C rate, then L1_SR_HEADER.BITRATE_CODE is 1. If the SCI-REC contained a mixture
	   2849 C of bit rates (some high, some low), then L1_SR_HEADER.BITRATE_CODE is 3.
	   2850 C
	   2851           IF (SCI(1).EDB(SPIN).BitRate) THEN
	   2852 C
	   2853 C If a spin is high bit rate set bit 1 of L1_SR_HEADER.BITRATE_CODE.
	   2854 C
	   2855             L1_SR_HEADER.BITRATE_CODE = IBSET(L1_SR_HEADER.BITRATE_CODE,1)
	   2856           ELSE
	   2857 C
	   2858 C If a spin is low bit rate set bit 0  of L1_SR_HEADER.BITRATE_CODE.
	   2859 C
	   2860             L1_SR_HEADER.BITRATE_CODE = IBSET(L1_SR_HEADER.BITRATE_CODE,0)
	   2861           ENDIF
	   2862 C

WIND_BUILD_SR_HEADER                                             1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  12
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

	   2863 C If there are any PHA words scan them for any zeros
	   2864 C If a zero PHA word is found (an illegal value) set the corresponding bit
	   2865 C in the bit array ZERO_SWICS_PHA
	   2866 C
	   2867 	  IF (SCI(1).EDB(SPIN).SWICS_Len .NE. 0) THEN
	   2868 	    CALL SCAN_ZERO_PHA( SWICS_PHA(1).EDB(SPIN).PHA, 
	   2869      &				SCI(1).EDB(SPIN).SWICS_Len*4,
	   2870      &				4, ZERO_COUNT, WHERE )
	   2871 	    IF (ZERO_COUNT .NE. 0) L1_SR_HEADER.ZERO_SWICS_PHA(SPIN/32+1) =
	   2872      &	      IBSET( L1_SR_HEADER.ZERO_SWICS_PHA(SPIN/32+1), MOD(SPIN,32) ) 
	   2873           ENDIF
	   2874 C
	   2875 C If there are any PHA words scan them for any zeros
	   2876 C If a zero PHA word is found (an illegal value) set the corresponding bit
	   2877 C in the bit array ZERO_MASS_PHA
	   2878 C
	   2879 	  IF (SCI(1).EDB(SPIN).MASS_Len .NE. 0) THEN
	   2880 	    CALL SCAN_ZERO_PHA( MASS_PHA(1).EDB(SPIN).PHA, 
	   2881      &				SCI(1).EDB(SPIN).MASS_Len*2,
	   2882      &				2, ZERO_COUNT, WHERE )
	   2883 	    IF (ZERO_COUNT .NE. 0) L1_SR_HEADER.ZERO_MASS_PHA(SPIN/32+1) =
	   2884      &	      IBSET( L1_SR_HEADER.ZERO_MASS_PHA(SPIN/32+1), MOD(SPIN,32) ) 
	   2885           ENDIF
	   2886 C
	   2887 C If there are any PHA words scan them for any zeros
	   2888 C If a zero PHA word is found (an illegal value) set the corresponding bit
	   2889 C in the bit array ZERO_STICS_PHA
	   2890 C
	   2891 	  IF (SCI(1).EDB(SPIN).STICS_Len .NE. 0) THEN
	   2892 	    CALL SCAN_ZERO_PHA( STICS_PHA(1).EDB(SPIN).PHA, 
	   2893      &				SCI(1).EDB(SPIN).STICS_Len*4,
	   2894      &				4, ZERO_COUNT, WHERE )
	   2895 	    IF (ZERO_COUNT .NE. 0) L1_SR_HEADER.ZERO_STICS_PHA(SPIN/32+1) =
	   2896      &	      IBSET( L1_SR_HEADER.ZERO_STICS_PHA(SPIN/32+1), MOD(SPIN,32) ) 
	   2897           ENDIF
	   2898 C
	   2899 C Set FIRST_VALID if this spin has good quality, but only do it once, i.e.
	   2900 C FIRST_VALID points to the first good spin in the science record
	   2901 C
	   2902           IF(FIRST_VALID.EQ.-1)FIRST_VALID=SPIN
	   2903         ENDIF
	   2904  100  CONTINUE
	   2905 C
	   2906 C Construct the Science Record counter as given in the HDB
	   2907 C
	   2908       SRCOUNT = HDB(1).BDH.DAT( 5 )
	   2909       SRCOUNT = SRCOUNT .AND. 'FF'X
	   2910       TEMP    = HDB(1).BDH.DAT( 4 )
	   2911       SRCOUNT = IOR( ISHFT( (TEMP .AND. 'FF'X), 8 ), SRCOUNT )
	   2912       TEMP    = HDB(1).BDH.DAT( 3 )
	   2913       SRCOUNT = IOR( ISHFT( (TEMP .AND. 'FF'X),16 ), SRCOUNT )
	   2914       L1_SR_HEADER.SR_COUNT = SRCOUNT
	   2915 C
	   2916 C If FIRST_VALID is -1, skip what follows, because there are no valid spins in
	   2917 C this science record. Also, if the epoch data is not available at processing
	   2918 C time, skip what follows.
	   2919 C

WIND_BUILD_SR_HEADER                                             1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  13
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

	   2920       IF((FIRST_VALID.NE.-1).AND.(EPH_AVAIL))THEN
	   2921 C
	   2922 C Since EPOCH and EPH_EPOCH are monotonically increasing, we don't need to reset
	   2923 C EPH_INDEX each time.
	   2924 C
	   2925 c	type 204,'looking for match to time ',SCI(1).EDB(FIRST_VALID).EPOCH 
	   2926 c204	format(1x,a,f20.0)
	   2927         DO 200 WHILE( (EPH_INDEX .LE. MAX_EPH_INDEX) .AND.
	   2928      &                (SCI(1).EDB(FIRST_VALID).EPOCH .GE. EPH_EPOCH(EPH_INDEX)))
	   2929 C	  TYPE 201,EPH_INDEX,EPH_EPOCH(EPH_INDEX)
	   2930 C201	  FORMAT(1X,I3,2X,F20.0)
	   2931           EPH_INDEX = EPH_INDEX + 1
	   2932  200    CONTINUE
	   2933 	EPH_INDEX = MAX(EPH_INDEX - 1, 1)
	   2934 c	type 203,eph_index,EPH_EPOCH(EPH_INDEX)
	   2935 c203	format(1x,'Found matching time at index ',i3,', value = ',f20.0)
	   2936 C
	   2937         L1_SR_HEADER.GCI_POS = GCI_POS(EPH_INDEX)
	   2938         L1_SR_HEADER.GCI_VEL = GCI_VEL(EPH_INDEX)
	   2939         L1_SR_HEADER.GSE_POS = GSE_POS(EPH_INDEX)
	   2940         L1_SR_HEADER.GSE_VEL = GSE_VEL(EPH_INDEX)
	   2941         L1_SR_HEADER.GSM_POS = GSM_POS(EPH_INDEX)
	   2942         L1_SR_HEADER.GSM_VEL = GSM_VEL(EPH_INDEX)
	   2943         L1_SR_HEADER.GCI_SUN_VECTOR = GCI_SUN_VECTOR(EPH_INDEX)
	   2944         L1_SR_HEADER.SPIN_RATE = SPIN_RATE(EPH_INDEX)
	   2945         L1_SR_HEADER.GCI_ATT = GCI_ATT(EPH_INDEX)
	   2946         L1_SR_HEADER.GSE_ATT = GSE_ATT(EPH_INDEX)
	   2947         L1_SR_HEADER.GSM_ATT = GSM_ATT(EPH_INDEX)
	   2948       ENDIF
	   2949 C
	   2950       RETURN
	   2951       END

WIND_BUILD_SR_HEADER                                             1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  14
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76



PROGRAM SECTIONS

    Name				 Bytes   Attributes

  1 $DATA$                                 200 NOPIC CON REL LCL NOSHR NOEXE   RD   WRT OCTA
  2 $BSS$                                  600 NOPIC CON REL LCL NOSHR NOEXE   RD   WRT OCTA
  3 $IODATA$                               200 NOPIC CON REL LCL NOSHR NOEXE   RD   WRT OCTA
  4 $CODE$                                6312   PIC CON REL LCL   SHR   EXE NORD NOWRT OCTA
  5 $LINK$                                 840 NOPIC CON REL LCL NOSHR NOEXE   RD NOWRT OCTA
  6 EDB                                 454336 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
  7 EDB_HEADER                              20 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
  8 HDB                                    996 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
  9 HK                                    3912 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 10 L1_HEADERS                             644 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 11 DIAG                                    48 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 12 L1INFO                                  40 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 13 FILE                                   160 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 14 DATES                                   32 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 15 EPHDATA                              29384 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 16 GETDATEINFO                             60 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA

    Total Space Allocated               497784


ENTRY POINTS

    Address   Type  Name                
                                        
  4-00000B60        WIND_BUILD_SR_HEADER


VARIABLES

    Address   Type  Name                    Address   Type  Name                    Address   Type  Name               
                                                                                                                       
  7-00000006  L*1   BITRATE              12-00000004  I*4   L1_RECS_WRITTEN     REG-########  I*4   SRCOUNT            
      **      I*1   BYTE_VAR            REG-00000000  L*1   LOG_VAR               7-00000009  L*1   STICSPOWER         
 12-00000014  I*4   CURR_SCI_REC_NUMBER   7-00000008  L*1   MASSPOWER             1-00000098  I*4   STICS_H_RATE_SIZE  
 12-00000018  I*4   CURR_SPIN             1-00000094  I*4   MASS_RATE_SIZE        1-0000009C  I*4   STICS_N_RATE_SIZE  
  6-0006EEBC  I*4   EDBSET                1-000000AC  I*4   MAX_EPH_INDEX         2-00000048  I*4   STICS_RATE_SIZE    
  1-00000090  I*4   EDB_CORE_SIZE         7-0000000C  I*4   MEASSPIN              7-00000004  L*1   SUBS_ID            
 12-00000008  I*4   EDB_LOST             12-0000001C  L*4   NEW_SCI_REC           7-00000007  L*1   SWICSPOWER         
 12-0000000C  I*4   EDB_SKIP             15-000072C4  I*4   NREC_AT               1-000000A0  I*4   SWICS_H_RATE_SIZE  
 12-00000010  I*4   EDB_SUM              15-000072C0  I*4   NREC_OR               1-000000A4  I*4   SWICS_N_RATE_SIZE  
 12-00000020  L*4   EPH_AVAIL             7-0000000A  L*1   RAMCHECK              2-0000004C  I*4   SWICS_RATE_SIZE    
  1-000000A8# I*4   EPH_INDEX            12-00000000  I*4   SCI_REC_CNTR        REG-########  I*4   TEMP               
REG-00000004  I*4   FIRST_VALID           7-00000000  I*4   SFPERBLOCK            2-00000050  I*4   ZERO_COUNT         
 12-00000024  L*4   FROM_CD             REG-00000005  I*4   SPIN                                                       
  7-00000005  L*1   HDBFLAG               7-00000010  I*4   SPINCOUNT                                                  



WIND_BUILD_SR_HEADER                                             1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  15
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

RECORDS

    Address   Name            Structure                Bytes
                                                            
 10-00000000  L1_FILE_HEADER  ST_L1_FILE_HEADER          400
 10-00000190  L1_SR_HEADER    ST_L1_SR_HEADER            244


ARRAYS

     Address  Type  Name             Bytes  Dimensions

  6-00005688  I*1   CORE_DATA         1980  (0:10, 0:59, 3)
 15-00000000  R*8   EPH_EPOCH         1152  (144)
  8-000003CC  I*4   HDBTIME2            24  (2, 3)
  9-00000CF0  I*4   HKLOCI             300  (75)
  9-00000E1C  I*4   HKLOCJ             300  (75)
  9-00000CE4  I*4   HKSET               12  (3)
  7-0000000B  L*1   SPARFLAGS            1  (1)
 15-00007080  R*4   SPIN_RATE          576  (144)
  2-00000054  I*4   WHERE              400  (100)



RECORD ARRAYS

    Address   Name            Structure         Bytes  Dimensions

 15-00006300  GCI_ATT         ATTITUDE          1152  (144)
 15-00000480  GCI_POS         EPHEMERIS         3456  (144)
 15-00005580  GCI_SUN_VECTOR  EPHEMERIS         3456  (144)
 15-00001200  GCI_VEL         EPHEMERIS         3456  (144)
 15-00006780  GSE_ATT         ATTITUDE          1152  (144)
 15-00001F80  GSE_POS         EPHEMERIS         3456  (144)
 15-00002D00  GSE_VEL         EPHEMERIS         3456  (144)
 15-00006C00  GSM_ATT         ATTITUDE          1152  (144)
 15-00003A80  GSM_POS         EPHEMERIS         3456  (144)
 15-00004800  GSM_VEL         EPHEMERIS         3456  (144)
  8-00000000  HDB             HDBSTR             972  (3)
  9-00000000  HKEEP           HKEEP             3300  (3)
  6-0004D424  MASS_PHA        MA_PHA          137880  (3)
  6-0004BDA4  MASS_RATE       MA_RATE           5760  (3)
  6-00000000  SCI             CORE             22152  (3)
  6-00030F54  STICS_PHA       ST_PHA          110160  (3)
  6-00028DF4  STICS_RATE      ST_RATE          33120  (3)
  6-0000B2A4  SWICS_PHA       SW_PHA          121680  (3)
  6-00005E44  SWICS_RATE      SW_RATE          21600  (3)




WIND_BUILD_SR_HEADER                                             1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  16
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

LABELS

    Address   Label     Address   Label
                                       
  4-00000E00   100        **       200 


FUNCTIONS AND SUBROUTINES REFERENCED

  Type  Name               
                           
        SCAN_ZERO_PHA      

WIND_BUILD_SR_HEADER                                             1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  17
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

	   2953 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
	   2954 	SUBROUTINE DOY_TO_MONTH_DAY( YEAR, DOY, MONTH, DAY, DATE_STR )
	   2955 C+
	   2956 C 
	   2957 C FUNCTIONAL DESCRIPTION:	
	   2958 C 
	   2959 C    This routine converts a given day of year to a (numeric) month and day.
	   2960 C    The `YEAR' argument is needed to distinguish leap from non-leap years.  In
	   2961 C    addition, the argument `DATE_STR' is filled with a formatted date string of
	   2962 C    the form DD-MMM-YYYY.
	   2963 C 
	   2964 C FORMAL PARAMETERS:
	   2965 C  
	   2966 C     YEAR:
	   2967 C	  An INTEGER*4 variable containing the year of the date.
	   2968 C      
	   2969 C     DOY:
	   2970 C	  An INTEGER*4 variable containing the day of the year.
	   2971 C      
	   2972 C     MONTH:
	   2973 C	  An INTEGER*4 variable which will receive the computed month (1
	   2974 C	  origin).
	   2975 C      
	   2976 C     DAY:
	   2977 C	  An INTEGER*4 variable which will receive the computed day-of-month.
	   2978 C      
	   2979 C     DATE_STR:
	   2980 C	  A CHARACTER*11 variable which will receive a formatted date string of
	   2981 C	  the form DD-MMM-YYYY, where DD is the number day of the month (with
	   2982 C	  leading blank if necessary) and MMM is the month's 3-letter
	   2983 C	  abbreviation. 
	   2984 C  
	   2985 C COMMON BLOCKS:
	   2986 C  
	   2987 C     None.
	   2988 C  
	   2989 C DESIGN:
	   2990 C  
	   2991 C     Scan array of days-in-year-to-date, locate month whose beginning
	   2992 C     day-of-year is the largest one less than the given day-of-year.
	   2993 C     Subtract this value from given day-of-year to get day-of-month.
	   2994 C     Take into account leap years by using alternate set of values.
	   2995 C  
	   2996 C 
	   2997 C This version:   9-FEB-1995 
	   2998 C 
	   2999 C Created: 
	   3000 C 
	   3001 C	 14-OCT-1994    L. Bleau
	   3002 C 
	   3003 C Revised:
	   3004 C 
	   3005 C	 Date     |    Name    | Description
	   3006 C ----------------+------------+-----------------------------------------------------
	   3007 C     17-OCT-1994 | J.PAQUETTE | Altered logic to determine MONTH and DAY
	   3008 C
	   3009 C-

DOY_TO_MONTH_DAY                                                 1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  18
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

	   3010 	IMPLICIT NONE
	   3011 	INTEGER*4 YEAR, DOY, MONTH, DAY
	   3012 	CHARACTER*11 DATE_STR
	   3013 C
	   3014 	CHARACTER*3 MONTH_ABBREV(12)
	   3015 	INTEGER MONTHS_END(12,2),LEAP
	   3016 	DATA MONTH_ABBREV/'JAN','FEB','MAR','APR','MAY','JUN',
	   3017      &			  'JUL','AUG','SEP','OCT','NOV','DEC'/
	   3018 	DATA MONTHS_END/31,59,90,120,151,181,212,243,273,304,334,365,
	   3019      &	                31,60,91,121,152,182,213,244,274,305,335,366/
	   3020 C
	   3021 	LEAP = 1                                                     ! Not a leap year
	   3022 	IF (MOD(YEAR,4) .EQ. 0 .AND. MOD(YEAR,100) .NE. 0) LEAP = 2  ! Leap year
	   3023 C
	   3024 C Test for error condition
	   3025 C
	   3026         IF((DOY.LT.1).OR.(DOY.GT.364+LEAP))THEN
	   3027           DAY   = -1
	   3028           MONTH = -1
	   3029           RETURN
	   3030         ENDIF
	   3031 C
	   3032 	DO MONTH=1,12
	   3033 	  IF (DOY .LE. MONTHS_END(MONTH,LEAP)) GOTO 100
	   3034 	END DO
	   3035 C
	   3036 100	IF(MONTH.EQ.1)THEN
	   3037 C
	   3038 C If this is the first month, the day-of-year and day-of-month are the same.
	   3039 C
	   3040           DAY=DOY
	   3041         ELSE
	   3042 C
	   3043 C If this is not the first month, subtract the day-of-year on which the previous 
	   3044 C month ended to get the day-of-month.
	   3045 C
	   3046           DAY = DOY - MONTHS_END(MONTH - 1,LEAP)        ! Subtract DOY of
	   3047         ENDIF
	   3048 C
	   3049 	WRITE(DATE_STR,1001) DAY,MONTH_ABBREV(MONTH),YEAR
	   3050 1001  	FORMAT(I2,1H-,A3,1H-,I4)
	   3051 C
	   3052 	RETURN
	   3053 	END

DOY_TO_MONTH_DAY                                                 1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  19
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76



PROGRAM SECTIONS

    Name				 Bytes   Attributes

  1 $DATA$                                 200 NOPIC CON REL LCL NOSHR NOEXE   RD   WRT OCTA
  2 $BSS$                                  600 NOPIC CON REL LCL NOSHR NOEXE   RD   WRT OCTA
  3 $IODATA$                               200 NOPIC CON REL LCL NOSHR NOEXE   RD   WRT OCTA
  4 $CODE$                                6312   PIC CON REL LCL   SHR   EXE NORD NOWRT OCTA
  5 $LINK$                                 840 NOPIC CON REL LCL NOSHR NOEXE   RD NOWRT OCTA
  6 EDB                                 454336 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
  7 EDB_HEADER                              20 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
  8 HDB                                    996 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
  9 HK                                    3912 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 10 L1_HEADERS                             644 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 11 DIAG                                    48 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 12 L1INFO                                  40 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 13 FILE                                   160 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 14 DATES                                   32 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 15 EPHDATA                              29384 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 16 GETDATEINFO                             60 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA

    Total Space Allocated               497784


ENTRY POINTS

    Address   Type  Name            
                                    
  4-000010B8        DOY_TO_MONTH_DAY


VARIABLES

    Address   Type  Name         Address   Type  Name         Address   Type  Name    
                                                                                      
      **      CHAR  DATE_STR       **      I*4   DOY            **      I*4   MONTH   
      **      I*4   DAY      REG-00000012  I*4   LEAP           **      I*4   YEAR    


ARRAYS

     Address  Type  Name                Bytes  Dimensions

  1-00000030  I*4   MONTHS_END             96  (12, 2)
  1-00000008  CHAR  MONTH_ABBREV           36  (12)




DOY_TO_MONTH_DAY                                                 1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  20
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

LABELS

    Address   Label     Address   Label
                                       
  4-00001264   100        **       1001

GET_CDT                                                          1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  21
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

	   3055 	SUBROUTINE GET_CDT(filename,ascii_date,day_of_year)
	   3056 C+
	   3057 C 
	   3058 C FUNCTIONAL DESCRIPTION:       
	   3059 C 
	   3060 C  This subroutine obtains the creation date of the specified file in ASCII
	   3061 C  format (VMS external format, 23 characters).  It also computes the day of
	   3062 C  the year for that date.
	   3063 C
	   3064 C FORMAL PARAMETERS:
	   3065 C  
	   3066 C     filename:
	   3067 C	  A CHARACTER variable containing the name of the file whose creation
	   3068 C	  date is desired.
	   3069 C
	   3070 C     ascii_date:
	   3071 C	  A CHARACTER*23 variable array which, upon return, will contain the
	   3072 C	  creation date in VMS external date format (NN-MMM-YYYY HH:MM:SS.HH).
	   3073 C
	   3074 C     day_of_year:
	   3075 C	  An INTEGER*4 variable which, upon return, will contain the day of
	   3076 C	  year of the creation date.
	   3077 C  
	   3078 C COMMON BLOCKS:
	   3079 C  
	   3080 C   None
	   3081 C  
	   3082 C DESIGN:
	   3083 C  
	   3084 C   Use routine GET_CREATE_DATE to do the hard work.  Use library routine
	   3085 C   LIB$CONVERT_DATE_STRING to obtain the internal time format for the first
	   3086 C   day of the year in which the file was created.  Now call LIB$DAY twice to
	   3087 C   get the number of days from November 17, 1858 (which DEC uses as zero
	   3088 C   origin) to the 1) start of the year in which the file was created, and
	   3089 C   2) to the date the file was created.  Subtract these two and add one to get
	   3090 C   the day of year value. 
	   3091 C  
	   3092 C This version:   1.0    15-MAR-1995
	   3093 C 
	   3094 C Created: 
	   3095 C 
	   3096 C	15-MAR-1995	Larry Bleau
	   3097 C 
	   3098 C-
	   3099 	IMPLICIT NONE
	   3100 	CHARACTER*(*) filename,ascii_date
	   3101 	INTEGER*4 day_of_year
	   3102 C
	   3103 	CHARACTER year_start*11
	   3104 	INTEGER*4 ios,quad_date(2),year_start_internal(2)
	   3105 	INTEGER*2 ndays1,ndays2
	   3106 C
	   3107 C Get the creation date in quadword (internal) format and in ASCII (external)
	   3108 C format
	   3109 C
	   3110 	CALL GET_CREATE_DATE(filename,quad_date,ascii_date)
 C	   3111 D	type *,'Creation: ',ascii_date

GET_CDT                                                          1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  22
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

 C	   3112 D	type *,'Year:     ',ascii_date(8:11)
	   3113 C
	   3114 C Compute day of year.
	   3115 C First get quadword time for first day of year.  Then get number of days from
	   3116 C November 17, 1858 to start of year and to file's creation date.  Difference
	   3117 C the two to get day of year file was created.
	   3118 C NOTE: Since the value returned by LIB$DAY is an *unsigned* 16-bit quantity
	   3119 C just TYPEing it out may produce a negative value.  The arithmetic still
	   3120 C works, though.
	   3121 C
	   3122 	year_start = ' 1-JAN-' // ascii_date(8:11)
	   3123 	CALL LIB$CONVERT_DATE_STRING (year_start, year_start_internal,,,,)
	   3124 	CALL LIB$DAY (ndays1, year_start_internal, )
	   3125 	CALL LIB$DAY (ndays2, quad_date, )
 C	   3126 D	type *,ndays1,ndays2
	   3127 	day_of_year = ndays2 - ndays1 + 1
 C	   3128 D	type *,'Doy:      ',day_of_year
	   3129 	RETURN
	   3130 	END


PROGRAM SECTIONS

    Name				 Bytes   Attributes

  1 $DATA$                                 200 NOPIC CON REL LCL NOSHR NOEXE   RD   WRT OCTA
  2 $BSS$                                  600 NOPIC CON REL LCL NOSHR NOEXE   RD   WRT OCTA
  3 $IODATA$                               200 NOPIC CON REL LCL NOSHR NOEXE   RD   WRT OCTA
  4 $CODE$                                6312   PIC CON REL LCL   SHR   EXE NORD NOWRT OCTA
  5 $LINK$                                 840 NOPIC CON REL LCL NOSHR NOEXE   RD NOWRT OCTA
  6 EDB                                 454336 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
  7 EDB_HEADER                              20 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
  8 HDB                                    996 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
  9 HK                                    3912 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 10 L1_HEADERS                             644 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 11 DIAG                                    48 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 12 L1INFO                                  40 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 13 FILE                                   160 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 14 DATES                                   32 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 15 EPHDATA                              29384 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 16 GETDATEINFO                             60 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA

    Total Space Allocated               497784


ENTRY POINTS

    Address   Type  Name   
                           
  4-000013E0        GET_CDT



GET_CDT                                                          1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  23
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

VARIABLES

    Address   Type  Name            Address   Type  Name            Address   Type  Name            Address   Type  Name       
                                                                                                                               
      **      CHAR  ASCII_DATE        **      CHAR  FILENAME      2-00000010  I*2   NDAYS1        2-00000038  CHAR  YEAR_START 
      **      I*4   DAY_OF_YEAR   2-00000020  I*4   IOS           2-00000018  I*2   NDAYS2                                     


ARRAYS

     Address  Type  Name                       Bytes  Dimensions

  2-00000024  I*4   QUAD_DATE                      8  (2)
  2-0000002C  I*4   YEAR_START_INTERNAL            8  (2)



FUNCTIONS AND SUBROUTINES REFERENCED

  Type  Name                            Type  Name                         
                                                                           
        GET_CREATE_DATE                       LIB$DAY                      
        LIB$CONVERT_DATE_STRING                                            

GET_CREATE_DATE                                                  1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  24
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

	   3132 	SUBROUTINE get_create_date(filename,quad_date,ascii_date)
	   3133 C+
	   3134 C 
	   3135 C FUNCTIONAL DESCRIPTION:       
	   3136 C 
	   3137 C  This routine obtains the creation date of the specified file and returns it
	   3138 C  to the caller in two formats: quadword (VMS internal) and ASCII (VMS external,
	   3139 C  23 characters).
	   3140 C
	   3141 C FORMAL PARAMETERS:
	   3142 C
	   3143 C     filename:
	   3144 C	  A CHARACTER variable containing the name of the file whose creation
	   3145 C	  date is desired.
	   3146 C
	   3147 C     quad_date:
	   3148 C	  An INTEGER*4 array of length 2 (8 bytes total) which, upon return,
	   3149 C	  will contain the creation date in VMS internal date format.
	   3150 C
	   3151 C     ascii_date:
	   3152 C	  A CHARACTER*23 variable array which, upon return, will contain the
	   3153 C	  creation date in VMS external date format (NN-MMM-YYYY HH:MM:SS.HH).
	   3154 C  
	   3155 C COMMON BLOCKS:
	   3156 C
	   3157 C   GETDATEINFO     contains the XAB data structure which holds the creation
	   3158 C		    date
	   3159 C
	   3160 C DESIGN:
	   3161 C  
	   3162 C   Do an OPEN with USEROPEN=MYOPEN so the routine MYOPEN gets called.  It
	   3163 C   grabs the creation date and puts it in common block GETDATEINFO.  Close the
	   3164 C   file as we don't need to access it any more.  Copy the quadword time into
	   3165 C   the caller's argument.  Also translate it to ASCII and put it into the
	   3166 C   third argument.
	   3167 C  
	   3168 C This version:   1.0    15-MAR-1995
	   3169 C 
	   3170 C Created: 
	   3171 C 
	   3172 C	15-MAR-1995	Larry Bleau
	   3173 C			Algorithm provided by William P. Bame (bbame@trauma.ab.umd.edu)
	   3174 C-
	   3175 	IMPLICIT NONE
	   3176 	CHARACTER filename*(*),ascii_date*(*)
	   3177 	INTEGER*4 myopen,quad_date(2)
	   3178 C
	   3179 	INTEGER*4 quadword(2),lun
	   3180 	INTEGER*2 nbytes/8/
	   3181 	INCLUDE '($XABDEF)'
    1	   3182 !*** MODULE $XABDEF ***
    1	   3183 CDEC$ OPTIONS/ALIGN=(RECORDS=PACKED,COMMONS=PACKED)
    1	   3184  ! 
    1	   3185  !          definitions for all xabs
    1	   3186  !                 $xabdef
    1	   3187  ! 
    1	   3188  !   the first four fields are shared in common between all xabs

GET_CREATE_DATE                                                  1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  25
1.16                            Symbol Table                     4-NOV-1994 21:24:10    SYS$COMMON:[SYSLIB]FORSYSDEF.TLB;1($XABDEF)

    1	   3189  !   and hence are defined only once
    1	   3190  !   (the only exception is that the spare word may be used by some xabs)
    1	   3191  ! 
    1	   3192 	STRUCTURE /XABDEF/
    1	   3193 	    BYTE      XAB$B_COD			 !  xab id code 
    1	   3194 	    BYTE      XAB$B_BLN			 !  block length 
    1	   3195 	    INTEGER*2 %FILL				 !  (spare) 
    1	   3196 	    INTEGER*4 XAB$L_NXT			 !  xab chain link
    1	   3197 	    INTEGER*2 XAB$W_RVN
    1	   3198 	    INTEGER*2 %FILL
    1	   3199 	    UNION
    1	   3200 	        MAP
    1	   3201 	        INTEGER*4 XAB$Q_RDT(2)
    1	   3202 	        END MAP
    1	   3203 	        MAP
    1	   3204 	            INTEGER*4 XAB$L_RDT0
    1	   3205 	            INTEGER*4 XAB$L_RDT4
    1	   3206  ! COMMON AMONG DAT AND RDT XABS
    1	   3207 	        END MAP
    1	   3208 	    END UNION
    1	   3209 	END STRUCTURE	! XABDEF
    1	   3210 	STRUCTURE /XABDEF1/
    1	   3211 	    BYTE      %FILL(1:8)
    1	   3212 	    BYTE      %FILL				 ! THESE FIELDS WILL BE DEFINED LATER 
    1	   3213 	    BYTE      %FILL
    1	   3214 	    INTEGER*2 %FILL
    1	   3215 	    INTEGER*4 %FILL
    1	   3216 	    INTEGER*4 %FILL
    1	   3217 	    INTEGER*2 %FILL
    1	   3218 	    BYTE      XAB$B_BKZ			 ! COMMON TO FHC AND ALQ XABS 
    1	   3219 	END STRUCTURE	! XABDEF1
    1	   3220 	PARAMETER XAB$C_CXT_VER1 = '00000001'X	 !  RMS Context Extraction version 1
    1	   3221 CDEC$ END OPTIONS
    1	   3222  
	   3223 	INCLUDE '($XABDATDEF)'
    1	   3224 !*** MODULE $XABDATDEF ***
    1	   3225 CDEC$ OPTIONS/ALIGN=(RECORDS=PACKED,COMMONS=PACKED)
    1	   3226  ! 
    1	   3227  !         date/time xab definitions
    1	   3228  !                 $xabdatdef
    1	   3229  ! 
    1	   3230  ! 
    1	   3231 	PARAMETER XAB$C_DAT = '00000012'X	 !  xabdat id code 
    1	   3232 	PARAMETER XAB$K_DATLEN_V2 = '00000024'X	 !  Version 2 XABDAT length 
    1	   3233 	PARAMETER XAB$C_DATLEN_V2 = '00000024'X	 !  Version 2 XABDAT length 
    1	   3234 	PARAMETER XAB$K_DATLEN_V54 = '0000002C'X  !  length of XABDAT 
    1	   3235 	PARAMETER XAB$C_DATLEN_V54 = '0000002C'X  !  length of XABDAT 
    1	   3236 	PARAMETER XAB$K_DATLEN = '0000003C'X	 !  length of XABDAT 
    1	   3237 	PARAMETER XAB$C_DATLEN = '0000003C'X	 !  length of XABDAT 
    1	   3238 	STRUCTURE /XABDATDEF/
    1	   3239 	    BYTE      %FILL
    1	   3240 	    BYTE      %FILL
    1	   3241 	    INTEGER*2 %FILL
    1	   3242 	    INTEGER*4 %FILL				 ! HAS SAME COD, BLN, SPARE AND NXT FIELD 
    1	   3243  ! THESE 4 FIELDS ARE COMMON TO ALL XABS AND
    1	   3244  ! HAVE BEEN DEFINED BY $XABDEF
    1	   3245 	    INTEGER*2 %FILL				 ! REVISION !,DEFINED IN $XABDEF,SINCE COMMON TO DAT & RDT 

GET_CREATE_DATE                                                  1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  26
1.16                            Symbol Table                     4-NOV-1994 21:24:10    [SYSLIB]FORSYSDEF.TLB;1($XABDATDEF)

    1	   3246 	    INTEGER*2 %FILL				 !  spare 
    1	   3247 	    INTEGER*4 %FILL(2)			 !  revision date & time,defined in $xabdef 
    1	   3248 	    UNION
    1	   3249 	        MAP
    1	   3250 	        INTEGER*4 XAB$Q_CDT(2)			 !  creation date & time 
    1	   3251 	        END MAP
    1	   3252 	        MAP
    1	   3253 	            INTEGER*4 XAB$L_CDT0
    1	   3254 	            INTEGER*4 XAB$L_CDT4
    1	   3255 	        END MAP
    1	   3256 	    END UNION
    1	   3257 	    UNION
    1	   3258 	        MAP
    1	   3259 	        INTEGER*4 XAB$Q_EDT(2)			 !  expiration date & time 
    1	   3260 	        END MAP
    1	   3261 	        MAP
    1	   3262 	            INTEGER*4 XAB$L_EDT0
    1	   3263 	            INTEGER*4 XAB$L_EDT4
    1	   3264 	        END MAP
    1	   3265 	    END UNION
    1	   3266 	    UNION
    1	   3267 	        MAP
    1	   3268 	        INTEGER*4 XAB$Q_BDT(2)			 !  backup date and time 
    1	   3269 	        END MAP
    1	   3270 	        MAP
    1	   3271 	            INTEGER*4 XAB$L_BDT0
    1	   3272 	            INTEGER*4 XAB$L_BDT4
    1	   3273 	        END MAP
    1	   3274 	    END UNION
    1	   3275 	    UNION
    1	   3276 	        MAP
    1	   3277 	        INTEGER*4 XAB$Q_RCD(2)			 !  Recorded date and time 
    1	   3278 	        END MAP
    1	   3279 	        MAP
    1	   3280 	            INTEGER*4 XAB$L_RCD0
    1	   3281 	            INTEGER*4 XAB$L_RCD4
    1	   3282 	        END MAP
    1	   3283 	    END UNION
    1	   3284 	    UNION
    1	   3285 	        MAP
    1	   3286 	        INTEGER*4 XAB$Q_EFF(2)			 !  Effective date and time 
    1	   3287 	        END MAP
    1	   3288 	        MAP
    1	   3289 	            INTEGER*4 XAB$L_EFF0
    1	   3290 	            INTEGER*4 XAB$L_EFF4
    1	   3291 	        END MAP
    1	   3292 	    END UNION
    1	   3293 	END STRUCTURE	! XABDATDEF
    1	   3294 CDEC$ END OPTIONS
    1	   3295  
	   3296 	EXTERNAL MYOPEN
	   3297 C
	   3298 	STRUCTURE /XABUNION/
	   3299 	  UNION
	   3300 	    MAP
	   3301 	      RECORD /XABDEF/ XAB
	   3302 	    END MAP

GET_CREATE_DATE                                                  1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  27
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

	   3303 	    MAP
	   3304 	      RECORD /XABDATDEF/ XABDAT
	   3305 	    END MAP
	   3306 	  END UNION
	   3307 	END STRUCTURE
	   3308 	RECORD /XABUNION/ xabu
	   3309 C
	   3310 	COMMON /GETDATEINFO/ xabu
	   3311 C
	   3312 C Open file so useropen routine MYOPEN gets called, then close it again as we
	   3313 C don't need it.  Use a temporary unit number (one returned by LIB$GET_LUN)
	   3314 C since we don't know what's open or not. 
	   3315 C
	   3316 	call LIB$GET_LUN(lun)
	   3317 	OPEN(UNIT=lun,FILE=filename,STATUS='OLD',ERR=300,
	   3318      *	     READONLY,USEROPEN=myopen)
	   3319 	CLOSE(lun)
	   3320 	call LIB$FREE_LUN(lun)
	   3321 C
	   3322 C Copy the quadword date-time to the caller's argument.
	   3323 C Also translate the time into ASCII format for caller.
	   3324 C
	   3325 	CALL LIB$MOVC3 (nbytes, xabu.xabdat.xab$q_cdt, quad_date)
	   3326 	CALL SYS$ASCTIM(,ascii_date,quad_date,)
	   3327 	RETURN
	   3328 C
	   3329 C Come here if we got an error on the open attempt.  Set the date to zero and
	   3330 C the ascii string to blanks and return.
	   3331 C
	   3332 300	quad_date(1) = 0
	   3333 	quad_date(2) = 0
	   3334 	ascii_date = ' '
	   3335 	RETURN
	   3336 	END

GET_CREATE_DATE                                                  1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  28
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76



PROGRAM SECTIONS

    Name				 Bytes   Attributes

  1 $DATA$                                 200 NOPIC CON REL LCL NOSHR NOEXE   RD   WRT OCTA
  2 $BSS$                                  600 NOPIC CON REL LCL NOSHR NOEXE   RD   WRT OCTA
  3 $IODATA$                               200 NOPIC CON REL LCL NOSHR NOEXE   RD   WRT OCTA
  4 $CODE$                                6312   PIC CON REL LCL   SHR   EXE NORD NOWRT OCTA
  5 $LINK$                                 840 NOPIC CON REL LCL NOSHR NOEXE   RD NOWRT OCTA
  6 EDB                                 454336 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
  7 EDB_HEADER                              20 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
  8 HDB                                    996 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
  9 HK                                    3912 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 10 L1_HEADERS                             644 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 11 DIAG                                    48 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 12 L1INFO                                  40 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 13 FILE                                   160 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 14 DATES                                   32 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 15 EPHDATA                              29384 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 16 GETDATEINFO                             60 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA

    Total Space Allocated               497784


ENTRY POINTS

    Address   Type  Name           
                                   
  4-00001600        GET_CREATE_DATE


VARIABLES

    Address   Type  Name           Address   Type  Name      
                                                             
      **      CHAR  ASCII_DATE   2-00000008  I*4   LUN       
      **      CHAR  FILENAME     1-00000000  I*2   NBYTES    


RECORDS

    Address   Name  Structure        Bytes
                                          
 16-00000000  XABU  XABUNION            60



GET_CREATE_DATE                                                  1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  29
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

ARRAYS

     Address  Type  Name             Bytes  Dimensions

  2-00000000  I*4   QUADWORD             8  (2)
      **      I*4   QUAD_DATE            8  (2)



LABELS

    Address   Label
                   
      **       300 


FUNCTIONS AND SUBROUTINES REFERENCED

  Type  Name                 Type  Name                 Type  Name              
                                                                                
        LIB$FREE_LUN               LIB$MOVC3                  SYS$ASCTIM        
        LIB$GET_LUN          I*8   MYOPEN                                       

MYOPEN                                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  30
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

	   3338 	INTEGER*4 FUNCTION MYOPEN(FAB,RAB,LUN)
	   3339 C+
	   3340 C 
	   3341 C FUNCTIONAL DESCRIPTION:       
	   3342 C 
	   3343 C   This routine obtains a file's creation date and makes it available in the
	   3344 C   common block GETDATEINFO.
	   3345 C
	   3346 C   This is a useropen routine.  It is not called directly.  Rather, it is
	   3347 C   called when Fortran does an OPEN on a file and this routine name is
	   3348 C   specified by the USEROPEN= keyword. 
	   3349 C
	   3350 C FORMAL PARAMETERS:
	   3351 C  
	   3352 C     FAB:
	   3353 C	  A structure variable of type FABDEF containing the File Access Block
	   3354 C	  data structure of the file to be opened.
	   3355 C  
	   3356 C     RAB:
	   3357 C	  A structure variable of type RABDEF containing the Record Access Block
	   3358 C	  data structure of the file to be opened.
	   3359 C      
	   3360 C     LUN:
	   3361 C	  An INTEGER*4 variable containing the Fortran unit number of the file
	   3362 C	  to be opened.
	   3363 C  
	   3364 C COMMON BLOCKS:
	   3365 C  
	   3366 C   GETDATEINFO     contains the XAB data structure which holds the creation
	   3367 C		    date
	   3368 C  
	   3369 C DESIGN:
	   3370 C  
	   3371 C   This routine must complete the open operation by calling the SYS$OPEN and
	   3372 C   SYS$CONNECT system services.  Since the only purpose of this routine is to
	   3373 C   obtain the file's creation date no call to SYS$CONNECT is done and the
	   3374 C   caller closes the file.
	   3375 C
	   3376 C   The creation date is obtained by linking an XAB (eXtended Attribute BLock)
	   3377 C   data structure to the list of XABs pointed to by field FAB$L_XAB of the FAB
	   3378 C   structure.  The new XAB is filled in with a code telling SYS$OPEN to store
	   3379 C   the file's creation date in the XAB.  
	   3380 C  
	   3381 C This version:   1.0    15-MAR-1995
	   3382 C 
	   3383 C Created: 
	   3384 C 
	   3385 C	15-MAR-1995	Larry Bleau
	   3386 C			Algorithm provided by William P. Bame (bbame@trauma.ab.umd.edu)
	   3387 C-
	   3388 	IMPLICIT NONE
	   3389 	INCLUDE '($FABDEF)'
    1	   3390 !*** MODULE $FABDEF ***
    1	   3391 CDEC$ OPTIONS/ALIGN=(RECORDS=PACKED,COMMONS=PACKED)
    1	   3392  ! 
    1	   3393  ! 
    1	   3394  ! 	file access block (fab) definitions

MYOPEN                                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  31
1.16                            Symbol Table                     4-NOV-1994 21:24:10    SYS$COMMON:[SYSLIB]FORSYSDEF.TLB;1($FABDEF)

    1	   3395  ! 
    1	   3396  !    the fields thru ctx must not be modified due to
    1	   3397  !    commonality between fab/rab/xab
    1	   3398  ! 
    1	   3399 	PARAMETER FAB$C_BID = '00000003'X	 !  code for fab 
    1	   3400 	PARAMETER FAB$M_PPF_RAT = '00003FC0'X
    1	   3401 	PARAMETER FAB$M_PPF_IND = '00004000'X
    1	   3402 	PARAMETER FAB$M_PPIFI = '00008000'X
    1	   3403 	PARAMETER FAB$M_ASY = '00000001'X
    1	   3404 	PARAMETER FAB$M_MXV = '00000002'X
    1	   3405 	PARAMETER FAB$M_SUP = '00000004'X
    1	   3406 	PARAMETER FAB$M_TMP = '00000008'X
    1	   3407 	PARAMETER FAB$M_TMD = '00000010'X
    1	   3408 	PARAMETER FAB$M_DFW = '00000020'X
    1	   3409 	PARAMETER FAB$M_SQO = '00000040'X
    1	   3410 	PARAMETER FAB$M_RWO = '00000080'X
    1	   3411 	PARAMETER FAB$M_POS = '00000100'X
    1	   3412 	PARAMETER FAB$M_WCK = '00000200'X
    1	   3413 	PARAMETER FAB$M_NEF = '00000400'X
    1	   3414 	PARAMETER FAB$M_RWC = '00000800'X
    1	   3415 	PARAMETER FAB$M_DMO = '00001000'X
    1	   3416 	PARAMETER FAB$M_SPL = '00002000'X
    1	   3417 	PARAMETER FAB$M_SCF = '00004000'X
    1	   3418 	PARAMETER FAB$M_DLT = '00008000'X
    1	   3419 	PARAMETER FAB$M_NFS = '00010000'X
    1	   3420 	PARAMETER FAB$M_UFO = '00020000'X
    1	   3421 	PARAMETER FAB$M_PPF = '00040000'X
    1	   3422 	PARAMETER FAB$M_INP = '00080000'X
    1	   3423 	PARAMETER FAB$M_CTG = '00100000'X
    1	   3424 	PARAMETER FAB$M_CBT = '00200000'X
    1	   3425 	PARAMETER FAB$M_SYNCSTS = '00400000'X
    1	   3426 	PARAMETER FAB$M_RCK = '00800000'X
    1	   3427 	PARAMETER FAB$M_NAM = '01000000'X
    1	   3428 	PARAMETER FAB$M_CIF = '02000000'X
    1	   3429 	PARAMETER FAB$M_ESC = '08000000'X
    1	   3430 	PARAMETER FAB$M_TEF = '10000000'X
    1	   3431 	PARAMETER FAB$M_OFP = '20000000'X
    1	   3432 	PARAMETER FAB$M_KFO = '40000000'X
    1	   3433 	PARAMETER FAB$M_PUT = '00000001'X
    1	   3434 	PARAMETER FAB$M_GET = '00000002'X
    1	   3435 	PARAMETER FAB$M_DEL = '00000004'X
    1	   3436 	PARAMETER FAB$M_UPD = '00000008'X
    1	   3437 	PARAMETER FAB$M_TRN = '00000010'X
    1	   3438 	PARAMETER FAB$M_BIO = '00000020'X
    1	   3439 	PARAMETER FAB$M_BRO = '00000040'X
    1	   3440 	PARAMETER FAB$M_EXE = '00000080'X
    1	   3441 	PARAMETER FAB$M_SHRPUT = '00000001'X
    1	   3442 	PARAMETER FAB$M_SHRGET = '00000002'X
    1	   3443 	PARAMETER FAB$M_SHRDEL = '00000004'X
    1	   3444 	PARAMETER FAB$M_SHRUPD = '00000008'X
    1	   3445 	PARAMETER FAB$M_MSE = '00000010'X
    1	   3446 	PARAMETER FAB$M_NIL = '00000020'X
    1	   3447 	PARAMETER FAB$M_UPI = '00000040'X
    1	   3448 	PARAMETER FAB$M_ORG = '000000F0'X
    1	   3449 	PARAMETER FAB$C_SEQ = '00000000'X	 !  sequential 
    1	   3450 	PARAMETER FAB$C_REL = '00000010'X	 !  relative 
    1	   3451 	PARAMETER FAB$C_IDX = '00000020'X	 !  indexed 

MYOPEN                                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  32
1.16                            Symbol Table                     4-NOV-1994 21:24:10    SYS$COMMON:[SYSLIB]FORSYSDEF.TLB;1($FABDEF)

    1	   3452 	PARAMETER FAB$C_HSH = '00000030'X	 !  hashed 
    1	   3453 	PARAMETER FAB$M_FTN = '00000001'X
    1	   3454 	PARAMETER FAB$M_CR = '00000002'X
    1	   3455 	PARAMETER FAB$M_PRN = '00000004'X
    1	   3456 	PARAMETER FAB$M_BLK = '00000008'X
    1	   3457 	PARAMETER FAB$M_MSB = '00000010'X
    1	   3458 	PARAMETER FAB$C_RFM_DFLT = '00000002'X	 !  var len is default 
    1	   3459 	PARAMETER FAB$C_UDF = '00000000'X	 !  undefined (also stream binary) 
    1	   3460 	PARAMETER FAB$C_FIX = '00000001'X	 !  fixed length records 
    1	   3461 	PARAMETER FAB$C_VAR = '00000002'X	 !  variable length records 
    1	   3462 	PARAMETER FAB$C_VFC = '00000003'X	 !  variable fixed control 
    1	   3463 	PARAMETER FAB$C_STM = '00000004'X	 !  RMS-11 stream (valid only for sequential org) 
    1	   3464 	PARAMETER FAB$C_STMLF = '00000005'X	 !  LF stream (valid only for sequential org) 
    1	   3465 	PARAMETER FAB$C_STMCR = '00000006'X	 !  CR stream (valid only for sequential org) 
    1	   3466 	PARAMETER FAB$C_MAXRFM = '00000006'X	 !  maximum rfm supported 
    1	   3467 	PARAMETER FAB$M_ONLY_RU = '00000001'X
    1	   3468 	PARAMETER FAB$M_RU = '00000002'X
    1	   3469 	PARAMETER FAB$M_BI = '00000004'X
    1	   3470 	PARAMETER FAB$M_AI = '00000008'X
    1	   3471 	PARAMETER FAB$M_AT = '00000010'X
    1	   3472 	PARAMETER FAB$M_NEVER_RU = '00000020'X
    1	   3473 	PARAMETER FAB$M_JOURNAL_FILE = '00000040'X
    1	   3474 	PARAMETER FAB$M_RCF_RU = '00000001'X
    1	   3475 	PARAMETER FAB$M_RCF_AI = '00000002'X
    1	   3476 	PARAMETER FAB$M_RCF_BI = '00000004'X
    1	   3477 	PARAMETER FAB$K_BLN = '00000050'X	 !  length of fab 
    1	   3478 	PARAMETER FAB$C_BLN = '00000050'X	 !  length of fab 
    1	   3479 	STRUCTURE /FABDEF/
    1	   3480 	    BYTE      FAB$B_BID			 !  block id 
    1	   3481 	    BYTE      FAB$B_BLN			 !  block len 
    1	   3482 	    UNION
    1	   3483 	        MAP
    1	   3484 	        INTEGER*2 FAB$W_IFI			 !  internal file index 
    1	   3485 	        END MAP
    1	   3486 	        MAP
    1	   3487 	            PARAMETER FAB$S_PPF_RAT = 8
    1	   3488 	            PARAMETER FAB$V_PPF_RAT = 6		 !  rat value for process-permanent files 
    1	   3489 	            PARAMETER FAB$S_PPF_IND = 1
    1	   3490 	            PARAMETER FAB$V_PPF_IND = 14		 !  indirect access to process-permanent file
    1	   3491  !  (i.e., restricted operations)
    1	   3492 	            PARAMETER FAB$S_PPIFI = 1
    1	   3493 	            PARAMETER FAB$V_PPIFI = 15
    1	   3494 	            BYTE %FILL (2)				 !  indicates that this is PPF file
    1	   3495 	        END MAP
    1	   3496 	    END UNION
    1	   3497 	    UNION
    1	   3498 	        MAP
    1	   3499 	        INTEGER*4 FAB$L_FOP			 !  file options 
    1	   3500 	        END MAP
    1	   3501 	        MAP
    1	   3502 	            PARAMETER FAB$S_ASY = 1
    1	   3503 	            PARAMETER FAB$V_ASY = 0			 !  asynchronous operations
    1	   3504 	            PARAMETER FAB$S_MXV = 1
    1	   3505 	            PARAMETER FAB$V_MXV = 1			 !  maximize version number 
    1	   3506 	            PARAMETER FAB$S_SUP = 1
    1	   3507 	            PARAMETER FAB$V_SUP = 2			 !  supersede existing file 
    1	   3508 	            PARAMETER FAB$S_TMP = 1

MYOPEN                                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  33
1.16                            Symbol Table                     4-NOV-1994 21:24:10    SYS$COMMON:[SYSLIB]FORSYSDEF.TLB;1($FABDEF)

    1	   3509 	            PARAMETER FAB$V_TMP = 3			 !  create temporary file 
    1	   3510 	            PARAMETER FAB$S_TMD = 1
    1	   3511 	            PARAMETER FAB$V_TMD = 4			 !  create temp file marked for delete 
    1	   3512 	            PARAMETER FAB$S_DFW = 1
    1	   3513 	            PARAMETER FAB$V_DFW = 5			 !  deferred write (rel and idx) 
    1	   3514 	            PARAMETER FAB$S_SQO = 1
    1	   3515 	            PARAMETER FAB$V_SQO = 6			 !  sequential access only 
    1	   3516 	            PARAMETER FAB$S_RWO = 1
    1	   3517 	            PARAMETER FAB$V_RWO = 7			 !  rewind mt on open 
    1	   3518 	            PARAMETER FAB$S_POS = 1
    1	   3519 	            PARAMETER FAB$V_POS = 8			 !  use next magtape position 
    1	   3520 	            PARAMETER FAB$S_WCK = 1
    1	   3521 	            PARAMETER FAB$V_WCK = 9			 !  write checking 
    1	   3522 	            PARAMETER FAB$S_NEF = 1
    1	   3523 	            PARAMETER FAB$V_NEF = 10		 !  inhibit end of file positioning 
    1	   3524 	            PARAMETER FAB$S_RWC = 1
    1	   3525 	            PARAMETER FAB$V_RWC = 11		 !  rewind mt on close 
    1	   3526 	            PARAMETER FAB$S_DMO = 1
    1	   3527 	            PARAMETER FAB$V_DMO = 12		 !  dismount mt on close (not implemented) 
    1	   3528 	            PARAMETER FAB$S_SPL = 1
    1	   3529 	            PARAMETER FAB$V_SPL = 13		 !  spool file on close 
    1	   3530 	            PARAMETER FAB$S_SCF = 1
    1	   3531 	            PARAMETER FAB$V_SCF = 14		 !  submit command file on close 
    1	   3532 	            PARAMETER FAB$S_DLT = 1
    1	   3533 	            PARAMETER FAB$V_DLT = 15		 !  delete sub-option 
    1	   3534 	            PARAMETER FAB$S_NFS = 1
    1	   3535 	            PARAMETER FAB$V_NFS = 16		 !  non-file structured operation 
    1	   3536 	            PARAMETER FAB$S_UFO = 1
    1	   3537 	            PARAMETER FAB$V_UFO = 17		 !  user file open - no rms operations 
    1	   3538 	            PARAMETER FAB$S_PPF = 1
    1	   3539 	            PARAMETER FAB$V_PPF = 18		 !  process permanent file (pio segment) 
    1	   3540 	            PARAMETER FAB$S_INP = 1
    1	   3541 	            PARAMETER FAB$V_INP = 19		 !  process-permanent file is 'input' 
    1	   3542 	            PARAMETER FAB$S_CTG = 1
    1	   3543 	            PARAMETER FAB$V_CTG = 20		 !  contiguous extension 
    1	   3544 	            PARAMETER FAB$S_CBT = 1
    1	   3545 	            PARAMETER FAB$V_CBT = 21		 !  contiguous best try 
    1	   3546 	            PARAMETER FAB$S_SYNCSTS = 1
    1	   3547 	            PARAMETER FAB$V_SYNCSTS = 22		 !  Synchronous status notification for asynchronous
    1	   3547  rout
    1	   3548 	            PARAMETER FAB$S_RCK = 1
    1	   3549 	            PARAMETER FAB$V_RCK = 23		 !  read checking 
    1	   3550 	            PARAMETER FAB$S_NAM = 1
    1	   3551 	            PARAMETER FAB$V_NAM = 24		 !  use name block dvi, did, and/or fid fields for open 
    1	   3552 	            PARAMETER FAB$S_CIF = 1
    1	   3553 	            PARAMETER FAB$V_CIF = 25		 !  create if non-existent 
    1	   3554 	            PARAMETER FAB$S_ESC = 1
    1	   3555 	            PARAMETER FAB$V_ESC = 27		 !  'escape' to non-standard function ($modify) 
    1	   3556 	            PARAMETER FAB$S_TEF = 1
    1	   3557 	            PARAMETER FAB$V_TEF = 28		 !  truncate at eof on close (write-accessed seq. disk file 
    1	   3557 o
    1	   3558 					!  truncate at eof on close (write-accessed seq. disk file onl
    1	   3559 	            PARAMETER FAB$S_OFP = 1
    1	   3560 	            PARAMETER FAB$V_OFP = 29		 !  output file parse (only name type sticky) 
    1	   3561 	            PARAMETER FAB$S_KFO = 1
    1	   3562 	            PARAMETER FAB$V_KFO = 30		 !  known file open (image activator only release 1) 
    1	   3563 	        BYTE %FILL (4)

MYOPEN                                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  34
1.16                            Symbol Table                     4-NOV-1994 21:24:10    SYS$COMMON:[SYSLIB]FORSYSDEF.TLB;1($FABDEF)

    1	   3564 	        END MAP
    1	   3565 	    END UNION
    1	   3566 	    INTEGER*4 FAB$L_STS			 !  status 
    1	   3567 	    INTEGER*4 FAB$L_STV			 !  status value 
    1	   3568 	    INTEGER*4 FAB$L_ALQ			 !  allocation quantity 
    1	   3569 	    INTEGER*2 FAB$W_DEQ			 !  default allocation quantity 
    1	   3570 	    UNION
    1	   3571 	        MAP
    1	   3572 	        BYTE      FAB$B_FAC			 !  file access 
    1	   3573 	        END MAP
    1	   3574 	        MAP
    1	   3575 	            PARAMETER FAB$S_PUT = 1
    1	   3576 	            PARAMETER FAB$V_PUT = 0			 !  put access 
    1	   3577 	            PARAMETER FAB$S_GET = 1
    1	   3578 	            PARAMETER FAB$V_GET = 1			 !  get access 
    1	   3579 	            PARAMETER FAB$S_DEL = 1
    1	   3580 	            PARAMETER FAB$V_DEL = 2			 !  delete access 
    1	   3581 	            PARAMETER FAB$S_UPD = 1
    1	   3582 	            PARAMETER FAB$V_UPD = 3			 !  update access 
    1	   3583 	            PARAMETER FAB$S_TRN = 1
    1	   3584 	            PARAMETER FAB$V_TRN = 4			 !  truncate access 
    1	   3585 	            PARAMETER FAB$S_BIO = 1
    1	   3586 	            PARAMETER FAB$V_BIO = 5			 !  block i/o access 
    1	   3587 	            PARAMETER FAB$S_BRO = 1
    1	   3588 	            PARAMETER FAB$V_BRO = 6			 !  block and record i/o access 
    1	   3589 	            PARAMETER FAB$S_EXE = 1
    1	   3590 	            PARAMETER FAB$V_EXE = 7			 !  execute access (caller must be exec or kernel mo
    1	   3590 de, 
    1	   3591  !   ufo must also be set)
    1	   3592 	        BYTE %FILL (1)
    1	   3593 	        END MAP
    1	   3594 	    END UNION
    1	   3595 	    UNION
    1	   3596 	        MAP
    1	   3597 	        BYTE      FAB$B_SHR			 !  file sharing 
    1	   3598 	        END MAP
    1	   3599 	        MAP
    1	   3600 	            PARAMETER FAB$S_SHRPUT = 1
    1	   3601 	            PARAMETER FAB$V_SHRPUT = 0		 !  put access 
    1	   3602 	            PARAMETER FAB$S_SHRGET = 1
    1	   3603 	            PARAMETER FAB$V_SHRGET = 1		 !  get access 
    1	   3604 	            PARAMETER FAB$S_SHRDEL = 1
    1	   3605 	            PARAMETER FAB$V_SHRDEL = 2		 !  delete access 
    1	   3606 	            PARAMETER FAB$S_SHRUPD = 1
    1	   3607 	            PARAMETER FAB$V_SHRUPD = 3		 !  update access 
    1	   3608 	            PARAMETER FAB$S_MSE = 1
    1	   3609 	            PARAMETER FAB$V_MSE = 4			 !  multi-stream connects enabled 
    1	   3610 	            PARAMETER FAB$S_NIL = 1
    1	   3611 	            PARAMETER FAB$V_NIL = 5			 !  no sharing 
    1	   3612 	            PARAMETER FAB$S_UPI = 1
    1	   3613 	            PARAMETER FAB$V_UPI = 6			 !  user provided interlocking (allows multiple 
    1	   3614  !   writers to seq. files)
    1	   3615 	        BYTE %FILL (1)
    1	   3616 	        END MAP
    1	   3617 	    END UNION
    1	   3618 	    INTEGER*4 FAB$L_CTX			 !  user context 
    1	   3619  ! -----*****

MYOPEN                                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  35
1.16                            Symbol Table                     4-NOV-1994 21:24:10    SYS$COMMON:[SYSLIB]FORSYSDEF.TLB;1($FABDEF)

    1	   3620 	    BYTE      FAB$B_RTV			 !  retrieval window size 
    1	   3621 	    UNION
    1	   3622 	        MAP
    1	   3623 	        BYTE      FAB$B_ORG			 !  file organization 
    1	   3624 	        END MAP
    1	   3625 	        MAP
    1	   3626 	            PARAMETER FAB$S_ORG = 4
    1	   3627 	            PARAMETER FAB$V_ORG = 4
    1	   3628 	            BYTE %FILL (1)
    1	   3629 	        END MAP
    1	   3630 	    END UNION
    1	   3631 	    UNION
    1	   3632 	        MAP
    1	   3633 	        BYTE      FAB$B_RAT			 !  record format 
    1	   3634 	        END MAP
    1	   3635 	        MAP
    1	   3636 	            PARAMETER FAB$S_FTN = 1
    1	   3637 	            PARAMETER FAB$V_FTN = 0			 !  fortran carriage-ctl 
    1	   3638 	            PARAMETER FAB$S_CR = 1
    1	   3639 	            PARAMETER FAB$V_CR = 1			 !  lf-record-cr carriage ctl 
    1	   3640 	            PARAMETER FAB$S_PRN = 1
    1	   3641 	            PARAMETER FAB$V_PRN = 2			 !  print-file carriage ctl 
    1	   3642 	            PARAMETER FAB$S_BLK = 1
    1	   3643 	            PARAMETER FAB$V_BLK = 3			 !  records don't cross block boundaries 
    1	   3644 	            PARAMETER FAB$S_MSB = 1
    1	   3645 	            PARAMETER FAB$V_MSB = 4			 !  MSB formatted byte count
    1	   3646 	        BYTE %FILL (1)
    1	   3647 	        END MAP
    1	   3648 	    END UNION
    1	   3649 	    BYTE      FAB$B_RFM			 !  record format 
    1	   3650 	    UNION
    1	   3651 	        MAP
    1	   3652 	        BYTE      FAB$B_JOURNAL			 !  journaling options (from FH2$B_JOURNAL)
    1	   3653 	        END MAP
    1	   3654 	        MAP
    1	   3655  !  may be set at a time
    1	   3656 	            PARAMETER FAB$S_ONLY_RU = 1
    1	   3657 	            PARAMETER FAB$V_ONLY_RU = 0		 !  file is accessible only in recovery unit 
    1	   3658 	            PARAMETER FAB$S_RU = 1
    1	   3659 	            PARAMETER FAB$V_RU = 1			 !  enable recovery unit journal 
    1	   3660 	            PARAMETER FAB$S_BI = 1
    1	   3661 	            PARAMETER FAB$V_BI = 2			 !  enable before image journal 
    1	   3662 	            PARAMETER FAB$S_AI = 1
    1	   3663 	            PARAMETER FAB$V_AI = 3			 !  enable after image journal 
    1	   3664 	            PARAMETER FAB$S_AT = 1
    1	   3665 	            PARAMETER FAB$V_AT = 4			 !  enable audit trail journal 
    1	   3666 	            PARAMETER FAB$S_NEVER_RU = 1
    1	   3667 	            PARAMETER FAB$V_NEVER_RU = 5		 !  file is never accessible in recovery unit
    1	   3668 	            PARAMETER FAB$S_JOURNAL_FILE = 1
    1	   3669 	            PARAMETER FAB$V_JOURNAL_FILE = 6	 !  this is a journal file
    1	   3670 	        BYTE %FILL (1)
    1	   3671 	        END MAP
    1	   3672 	    END UNION
    1	   3673 	    BYTE      FAB$B_RU_FACILITY		 !  recoverable facility id number
    1	   3674 	    INTEGER*2 %FILL				 !  (spare)
    1	   3675 	    INTEGER*4 FAB$L_XAB			 !  xab address 
    1	   3676 	    INTEGER*4 FAB$L_NAM			 !  nam block address 

MYOPEN                                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  36
1.16                            Symbol Table                     4-NOV-1994 21:24:10    SYS$COMMON:[SYSLIB]FORSYSDEF.TLB;1($FABDEF)

    1	   3677 	    INTEGER*4 FAB$L_FNA			 !  file name string address 
    1	   3678 	    INTEGER*4 FAB$L_DNA			 !  default file name string addr 
    1	   3679 	    BYTE      FAB$B_FNS			 !  file name string size 
    1	   3680 	    BYTE      FAB$B_DNS			 !  default name string size 
    1	   3681 	    INTEGER*2 FAB$W_MRS			 !  maximum record size 
    1	   3682 	    INTEGER*4 FAB$L_MRN			 !  maximum record number 
    1	   3683 	    INTEGER*2 FAB$W_BLS			 !  blocksize for tape 
    1	   3684 	    BYTE      FAB$B_BKS			 !  bucket size 
    1	   3685 	    BYTE      FAB$B_FSZ			 !  fixed header size 
    1	   3686 	    INTEGER*4 FAB$L_DEV			 !  device characteristics 
    1	   3687 	    INTEGER*4 FAB$L_SDC			 !  spooling device characteristics 
    1	   3688 	    INTEGER*2 FAB$W_GBC			 !  Global buffer count 
    1	   3689 	    UNION
    1	   3690 	        MAP
    1	   3691 	        BYTE      FAB$B_ACMODES			 !  agent access modes
    1	   3692 	        END MAP
    1	   3693 	        MAP
    1	   3694 	            PARAMETER FAB$S_LNM_MODE = 2
    1	   3695 	            PARAMETER FAB$V_LNM_MODE = 0		 !  ACMODE for log nams
    1	   3696 	            PARAMETER FAB$S_CHAN_MODE = 2
    1	   3697 	            PARAMETER FAB$V_CHAN_MODE = 2		 !  ACMODE for channel
    1	   3698 	            PARAMETER FAB$S_FILE_MODE = 2
    1	   3699 	            PARAMETER FAB$V_FILE_MODE = 4		 !  ACMODE to use for determining file accessibility
    1	   3700 	            PARAMETER FAB$S_CALLERS_MODE = 2
    1	   3701 	            PARAMETER FAB$V_CALLERS_MODE = 6	 !  ACMODE for user structure probing;
    1	   3702  !  maximized with actual mode of caller
    1	   3703 	        BYTE %FILL (1)
    1	   3704 	        END MAP
    1	   3705 	    END UNION
    1	   3706 	    UNION
    1	   3707 	        MAP
    1	   3708 	        BYTE      FAB$B_RCF			 !  (only for use by RMS Recovery)
    1	   3709 	        END MAP
    1	   3710 	        MAP
    1	   3711 	            PARAMETER FAB$S_RCF_RU = 1
    1	   3712 	            PARAMETER FAB$V_RCF_RU = 0		 !  recovery unit recovery
    1	   3713 	            PARAMETER FAB$S_RCF_AI = 1
    1	   3714 	            PARAMETER FAB$V_RCF_AI = 1		 !  after image recovery
    1	   3715 	            PARAMETER FAB$S_RCF_BI = 1
    1	   3716 	            PARAMETER FAB$V_RCF_BI = 2		 !  before image recovery
    1	   3717 	        BYTE %FILL (1)
    1	   3718 	        END MAP
    1	   3719 	    END UNION
    1	   3720 	    INTEGER*4 %FILL				 !  (spare) 
    1	   3721 	END STRUCTURE	! FABDEF
    1	   3722 CDEC$ END OPTIONS
    1	   3723  
	   3724 	INCLUDE '($RABDEF)'
    1	   3725 !*** MODULE $RABDEF ***
    1	   3726 CDEC$ OPTIONS/ALIGN=(RECORDS=PACKED,COMMONS=PACKED)
    1	   3727  ! 
    1	   3728  !          record access block (rab) definitions
    1	   3729  ! 
    1	   3730  !   there is one rab per connected stream
    1	   3731  !   it is used for all communications between the user
    1	   3732  !   and rms concerning operations on the stream
    1	   3733  ! 

MYOPEN                                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  37
1.16                            Symbol Table                     4-NOV-1994 21:24:10    SYS$COMMON:[SYSLIB]FORSYSDEF.TLB;1($RABDEF)

    1	   3734  !   the fields thru ctx cannot be changed due to commonality
    1	   3735  !   with the fab
    1	   3736  ! 
    1	   3737 	PARAMETER RAB$C_BID = '00000001'X	 !  code for rab 
    1	   3738 	PARAMETER RAB$M_PPF_RAT = '00003FC0'X
    1	   3739 	PARAMETER RAB$M_PPF_IND = '00004000'X
    1	   3740 	PARAMETER RAB$M_PPISI = '00008000'X
    1	   3741 	PARAMETER RAB$M_ASY = '00000001'X
    1	   3742 	PARAMETER RAB$M_TPT = '00000002'X
    1	   3743 	PARAMETER RAB$M_REA = '00000004'X
    1	   3744 	PARAMETER RAB$M_RRL = '00000008'X
    1	   3745 	PARAMETER RAB$M_UIF = '00000010'X
    1	   3746 	PARAMETER RAB$M_MAS = '00000020'X
    1	   3747 	PARAMETER RAB$M_FDL = '00000040'X
    1	   3748 	PARAMETER RAB$M_REV = '00000080'X
    1	   3749 	PARAMETER RAB$M_EOF = '00000100'X
    1	   3750 	PARAMETER RAB$M_RAH = '00000200'X
    1	   3751 	PARAMETER RAB$M_WBH = '00000400'X
    1	   3752 	PARAMETER RAB$M_BIO = '00000800'X
    1	   3753 	PARAMETER RAB$M_CDK = '00001000'X
    1	   3754 	PARAMETER RAB$M_LOA = '00002000'X
    1	   3755 	PARAMETER RAB$M_LIM = '00004000'X
    1	   3756 	PARAMETER RAB$M_SYNCSTS = '00008000'X
    1	   3757 	PARAMETER RAB$M_LOC = '00010000'X
    1	   3758 	PARAMETER RAB$M_WAT = '00020000'X
    1	   3759 	PARAMETER RAB$M_ULK = '00040000'X
    1	   3760 	PARAMETER RAB$M_RLK = '00080000'X
    1	   3761 	PARAMETER RAB$M_NLK = '00100000'X
    1	   3762 	PARAMETER RAB$M_KGE = '00200000'X
    1	   3763 	PARAMETER RAB$M_KGT = '00400000'X
    1	   3764 	PARAMETER RAB$M_NXR = '00800000'X
    1	   3765 	PARAMETER RAB$M_RNE = '01000000'X
    1	   3766 	PARAMETER RAB$M_TMO = '02000000'X
    1	   3767 	PARAMETER RAB$M_CVT = '04000000'X
    1	   3768 	PARAMETER RAB$M_RNF = '08000000'X
    1	   3769 	PARAMETER RAB$M_ETO = '10000000'X
    1	   3770 	PARAMETER RAB$M_PTA = '20000000'X
    1	   3771 	PARAMETER RAB$M_PMT = '40000000'X
    1	   3772 	PARAMETER RAB$M_CCO = '80000000'X
    1	   3773 	PARAMETER RAB$M_EQNXT = '00200000'X
    1	   3774 	PARAMETER RAB$M_NXT = '00400000'X
    1	   3775 	PARAMETER RAB$C_SEQ = '00000000'X	 !  sequential access 
    1	   3776 	PARAMETER RAB$C_KEY = '00000001'X	 !  keyed access 
    1	   3777 	PARAMETER RAB$C_RFA = '00000002'X	 !  rfa access 
    1	   3778 	PARAMETER RAB$C_STM = '00000003'X	 !  stream access (valid only for sequential org) 
    1	   3779 	PARAMETER RAB$C_MAXRAC = '00000002'X	 !  Maximum RAC value currently supported by RMS
    1	   3780 	PARAMETER RAB$K_BLN = '00000044'X	 !  length of rab 
    1	   3781 	PARAMETER RAB$C_BLN = '00000044'X	 !  length of rab 
    1	   3782 	STRUCTURE /RABDEF/
    1	   3783 	    BYTE      RAB$B_BID			 !  block id 
    1	   3784 	    BYTE      RAB$B_BLN			 !  block length 
    1	   3785 	    UNION
    1	   3786 	        MAP
    1	   3787 	        INTEGER*2 RAB$W_ISI			 !  internal stream index 
    1	   3788 	        END MAP
    1	   3789  !  (ifi in fab)
    1	   3790 	        MAP

MYOPEN                                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  38
1.16                            Symbol Table                     4-NOV-1994 21:24:10    SYS$COMMON:[SYSLIB]FORSYSDEF.TLB;1($RABDEF)

    1	   3791 	            PARAMETER RAB$S_PPF_RAT = 8
    1	   3792 	            PARAMETER RAB$V_PPF_RAT = 6		 !  rat value for process-permanent files 
    1	   3793 	            PARAMETER RAB$S_PPF_IND = 1
    1	   3794 	            PARAMETER RAB$V_PPF_IND = 14		 !  indirect access to process-permanent file 
    1	   3795  !  (i.e., restricted operations)
    1	   3796 	            PARAMETER RAB$S_PPISI = 1
    1	   3797 	            PARAMETER RAB$V_PPISI = 15
    1	   3798 	            BYTE %FILL (2)				 !  indicates that this is process-permanent stream
    1	   3799 	        END MAP
    1	   3800 	    END UNION
    1	   3801 	    UNION
    1	   3802 	        MAP
    1	   3803 	        INTEGER*4 RAB$L_ROP			 !  record options 
    1	   3804 	        END MAP
    1	   3805 	        MAP
    1	   3806 	            PARAMETER RAB$S_ASY = 1
    1	   3807 	            PARAMETER RAB$V_ASY = 0			 !  asynchronous operations 
    1	   3808 	            PARAMETER RAB$S_TPT = 1
    1	   3809 	            PARAMETER RAB$V_TPT = 1			 !  truncate put - allow sequential put not at 
    1	   3810  !    eof, thus truncating file (seq. org only)
    1	   3811  ! 
    1	   3812  !  these next two should be in the byte for bits
    1	   3813  !  input to $find or $get, but there is no room there
    1	   3814  ! 
    1	   3815 	            PARAMETER RAB$S_REA = 1
    1	   3816 	            PARAMETER RAB$V_REA = 2			 !  lock record for read only, allow other readers 
    1	   3817 	            PARAMETER RAB$S_RRL = 1
    1	   3818 	            PARAMETER RAB$V_RRL = 3			 !  read record regardless of lock 
    1	   3819  ! 
    1	   3820 	            PARAMETER RAB$S_UIF = 1
    1	   3821 	            PARAMETER RAB$V_UIF = 4			 !  update if existent 
    1	   3822 	            PARAMETER RAB$S_MAS = 1
    1	   3823 	            PARAMETER RAB$V_MAS = 5			 !  mass-insert mode 
    1	   3824 	            PARAMETER RAB$S_FDL = 1
    1	   3825 	            PARAMETER RAB$V_FDL = 6			 !  fast record deletion 
    1	   3826 	            PARAMETER RAB$S_REV = 1
    1	   3827 	            PARAMETER RAB$V_REV = 7			 !  reverse-search - can only be set with NXT or EQN
    1	   3827 XT
    1	   3828  ! 
    1	   3829 	            PARAMETER RAB$S_EOF = 1
    1	   3830 	            PARAMETER RAB$V_EOF = 8			 !  connect to eof 
    1	   3831 	            PARAMETER RAB$S_RAH = 1
    1	   3832 	            PARAMETER RAB$V_RAH = 9			 !  read ahead 
    1	   3833 	            PARAMETER RAB$S_WBH = 1
    1	   3834 	            PARAMETER RAB$V_WBH = 10		 !  write behind 
    1	   3835 	            PARAMETER RAB$S_BIO = 1
    1	   3836 	            PARAMETER RAB$V_BIO = 11		 !  connect for bio only 
    1	   3837 	            PARAMETER RAB$S_CDK = 1
    1	   3838 	            PARAMETER RAB$V_CDK = 12		 !  check for duplicate keys on $GET
    1	   3839 	            PARAMETER RAB$S_LOA = 1
    1	   3840 	            PARAMETER RAB$V_LOA = 13		 !  use bucket fill percentage 
    1	   3841 	            PARAMETER RAB$S_LIM = 1
    1	   3842 	            PARAMETER RAB$V_LIM = 14		 !  compare for key limit reached on $get/$find seq. (idx on
    1	   3842 l
    1	   3843 					!  compare for key limit reached on $get/$find seq. (idx only)
    1	   3844 	            PARAMETER RAB$S_SYNCSTS = 1
    1	   3845 	            PARAMETER RAB$V_SYNCSTS = 15		 !  Synchronous status notification for asynchronous

MYOPEN                                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  39
1.16                            Symbol Table                     4-NOV-1994 21:24:10    SYS$COMMON:[SYSLIB]FORSYSDEF.TLB;1($RABDEF)

    1	   3845  rout
    1	   3846  ! 
    1	   3847  !  the following bits are input to
    1	   3848  !  $find or $get, (see above also REA and RRL)
    1	   3849  !  (separate byte)
    1	   3850  ! 
    1	   3851 	            PARAMETER RAB$S_LOC = 1
    1	   3852 	            PARAMETER RAB$V_LOC = 16		 !  use locate mode 
    1	   3853 	            PARAMETER RAB$S_WAT = 1
    1	   3854 	            PARAMETER RAB$V_WAT = 17		 !  wait if record not available 
    1	   3855 	            PARAMETER RAB$S_ULK = 1
    1	   3856 	            PARAMETER RAB$V_ULK = 18		 !  manual unlocking 
    1	   3857 	            PARAMETER RAB$S_RLK = 1
    1	   3858 	            PARAMETER RAB$V_RLK = 19		 !  allow readers for this locked record 
    1	   3859 	            PARAMETER RAB$S_NLK = 1
    1	   3860 	            PARAMETER RAB$V_NLK = 20		 !  do not lock record 
    1	   3861 	            PARAMETER RAB$S_KGE = 1
    1	   3862 	            PARAMETER RAB$V_KGE = 21		 !  key > or = 
    1	   3863 	            PARAMETER RAB$S_KGT = 1
    1	   3864 	            PARAMETER RAB$V_KGT = 22		 !  key greater than 
    1	   3865 	            PARAMETER RAB$S_NXR = 1
    1	   3866 	            PARAMETER RAB$V_NXR = 23		 !  get non-existent record 
    1	   3867  ! 
    1	   3868  !   the following bits are terminal qualifiers only
    1	   3869  !   (separate byte)
    1	   3870  ! 
    1	   3871 	            PARAMETER RAB$S_RNE = 1
    1	   3872 	            PARAMETER RAB$V_RNE = 24		 !  read no echo 
    1	   3873 	            PARAMETER RAB$S_TMO = 1
    1	   3874 	            PARAMETER RAB$V_TMO = 25		 !  use time-out period 
    1	   3875 	            PARAMETER RAB$S_CVT = 1
    1	   3876 	            PARAMETER RAB$V_CVT = 26		 !  convert to upper case 
    1	   3877 	            PARAMETER RAB$S_RNF = 1
    1	   3878 	            PARAMETER RAB$V_RNF = 27		 !  read no filter 
    1	   3879 	            PARAMETER RAB$S_ETO = 1
    1	   3880 	            PARAMETER RAB$V_ETO = 28		 !  extended terminal operation
    1	   3881 	            PARAMETER RAB$S_PTA = 1
    1	   3882 	            PARAMETER RAB$V_PTA = 29		 !  purge type ahead 
    1	   3883 	            PARAMETER RAB$S_PMT = 1
    1	   3884 	            PARAMETER RAB$V_PMT = 30		 !  use prompt buffer 
    1	   3885 	            PARAMETER RAB$S_CCO = 1
    1	   3886 	            PARAMETER RAB$V_CCO = 31
    1	   3887 	            BYTE %FILL (4)				 !  cancel control o on output 
    1	   3888 	        END MAP
    1	   3889 	        MAP
    1	   3890 	            PARAMETER RAB$S_EQNXT = 1
    1	   3891 	            PARAMETER RAB$V_EQNXT = 21		 !  Synonyms for KGE and
    1	   3892 	            PARAMETER RAB$S_NXT = 1
    1	   3893 	            PARAMETER RAB$V_NXT = 22		 !    KGT
    1	   3894 	        BYTE %FILL (1)
    1	   3895 	        END MAP
    1	   3896  !  the following bits may be
    1	   3897  !  input to various rab-related
    1	   3898  !  operations
    1	   3899  ! 
    1	   3900 	        MAP
    1	   3901 	            BYTE      %FILL

MYOPEN                                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  40
1.16                            Symbol Table                     4-NOV-1994 21:24:10    SYS$COMMON:[SYSLIB]FORSYSDEF.TLB;1($RABDEF)

    1	   3902 	            BYTE      RAB$B_ROP1			 !  various options 
    1	   3903 	            BYTE      RAB$B_ROP2			 !  get/find options (use of this field discouraged 
    1	   3904  !  due to REA and RRL being in a different byte)
    1	   3905 	            BYTE      RAB$B_ROP3			 !  terminal read options 
    1	   3906  ! 
    1	   3907 	        END MAP
    1	   3908 	    END UNION
    1	   3909 	    INTEGER*4 RAB$L_STS			 !  status 
    1	   3910 	    UNION
    1	   3911 	        MAP
    1	   3912 	        INTEGER*4 RAB$L_STV			 !  status value 
    1	   3913 	        END MAP
    1	   3914 	        MAP
    1	   3915 	            INTEGER*2 RAB$W_STV0			 !  low word of stv 
    1	   3916 	            INTEGER*2 RAB$W_STV2			 !  high word of stv 
    1	   3917 	        END MAP
    1	   3918 	    END UNION
    1	   3919 	    UNION
    1	   3920 	        MAP
    1	   3921 	        INTEGER*2 RAB$W_RFA(1:3)		 !  record's file address 
    1	   3922 	        END MAP
    1	   3923 	        MAP
    1	   3924 	            INTEGER*4 RAB$L_RFA0
    1	   3925 	            INTEGER*2 RAB$W_RFA4
    1	   3926 	        END MAP
    1	   3927 	    END UNION
    1	   3928 	    INTEGER*2 %FILL				 !  (reserved - rms release 1 optimizes stores 
    1	   3929  !   to the rfa field to be a move quad, overwriting
    1	   3930  !   this reserved word)
    1	   3931 	    INTEGER*4 RAB$L_CTX			 !  user context 
    1	   3932  ! -----*****
    1	   3933 	    INTEGER*2 %FILL				 !  (spare) 
    1	   3934 	    BYTE      RAB$B_RAC			 !  record access 
    1	   3935 	    BYTE      RAB$B_TMO			 !  time-out period 
    1	   3936 	    INTEGER*2 RAB$W_USZ			 !  user buffer size 
    1	   3937 	    INTEGER*2 RAB$W_RSZ			 !  record buffer size 
    1	   3938 	    INTEGER*4 RAB$L_UBF			 !  user buffer address 
    1	   3939 	    INTEGER*4 RAB$L_RBF			 !  record buffer address 
    1	   3940 	    INTEGER*4 RAB$L_RHB			 !  record header buffer addr 
    1	   3941 	    UNION
    1	   3942 	        MAP
    1	   3943 	        INTEGER*4 RAB$L_KBF			 !  key buffer address 
    1	   3944 	        END MAP
    1	   3945 	        MAP
    1	   3946 	        INTEGER*4 RAB$L_PBF			 !  prompt buffer addr 
    1	   3947 	        END MAP
    1	   3948 	    END UNION
    1	   3949 	    UNION
    1	   3950 	        MAP
    1	   3951 	        BYTE      RAB$B_KSZ			 !  key buffer size 
    1	   3952 	        END MAP
    1	   3953 	        MAP
    1	   3954 	        BYTE      RAB$B_PSZ			 !  prompt buffer size 
    1	   3955 	        END MAP
    1	   3956 	    END UNION
    1	   3957 	    BYTE      RAB$B_KRF			 !  key of reference 
    1	   3958 	    BYTE      RAB$B_MBF			 !  multi-buffer count 

MYOPEN                                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  41
1.16                            Symbol Table                     4-NOV-1994 21:24:10    SYS$COMMON:[SYSLIB]FORSYSDEF.TLB;1($RABDEF)

    1	   3959 	    BYTE      RAB$B_MBC			 !  multi-block count 
    1	   3960 	    UNION
    1	   3961 	        MAP
    1	   3962 	        INTEGER*4 RAB$L_BKT			 !  bucket hash code, vbn, or rrn 
    1	   3963 	        END MAP
    1	   3964 	        MAP
    1	   3965 	        INTEGER*4 RAB$L_DCT			 !  duplicates count on key accessed on alternate key 
    1	   3966 	        END MAP
    1	   3967 	    END UNION
    1	   3968 	    INTEGER*4 RAB$L_FAB			 !  related fab for connect 
    1	   3969 	    INTEGER*4 RAB$L_XAB			 !  XAB address 
    1	   3970 	END STRUCTURE	! RABDEF
    1	   3971 CDEC$ END OPTIONS
    1	   3972  
	   3973 	INCLUDE '($XABDEF)'
    1	   3974 !*** MODULE $XABDEF ***
    1	   3975 CDEC$ OPTIONS/ALIGN=(RECORDS=PACKED,COMMONS=PACKED)
    1	   3976  ! 
    1	   3977  !          definitions for all xabs
    1	   3978  !                 $xabdef
    1	   3979  ! 
    1	   3980  !   the first four fields are shared in common between all xabs
    1	   3981  !   and hence are defined only once
    1	   3982  !   (the only exception is that the spare word may be used by some xabs)
    1	   3983  ! 
    1	   3984 	STRUCTURE /XABDEF/
    1	   3985 	    BYTE      XAB$B_COD			 !  xab id code 
    1	   3986 	    BYTE      XAB$B_BLN			 !  block length 
    1	   3987 	    INTEGER*2 %FILL				 !  (spare) 
    1	   3988 	    INTEGER*4 XAB$L_NXT			 !  xab chain link
    1	   3989 	    INTEGER*2 XAB$W_RVN
    1	   3990 	    INTEGER*2 %FILL
    1	   3991 	    UNION
    1	   3992 	        MAP
    1	   3993 	        INTEGER*4 XAB$Q_RDT(2)
    1	   3994 	        END MAP
    1	   3995 	        MAP
    1	   3996 	            INTEGER*4 XAB$L_RDT0
    1	   3997 	            INTEGER*4 XAB$L_RDT4
    1	   3998  ! COMMON AMONG DAT AND RDT XABS
    1	   3999 	        END MAP
    1	   4000 	    END UNION
    1	   4001 	END STRUCTURE	! XABDEF
    1	   4002 	STRUCTURE /XABDEF1/
    1	   4003 	    BYTE      %FILL(1:8)
    1	   4004 	    BYTE      %FILL				 ! THESE FIELDS WILL BE DEFINED LATER 
    1	   4005 	    BYTE      %FILL
    1	   4006 	    INTEGER*2 %FILL
    1	   4007 	    INTEGER*4 %FILL
    1	   4008 	    INTEGER*4 %FILL
    1	   4009 	    INTEGER*2 %FILL
    1	   4010 	    BYTE      XAB$B_BKZ			 ! COMMON TO FHC AND ALQ XABS 
    1	   4011 	END STRUCTURE	! XABDEF1
    1	   4012 	PARAMETER XAB$C_CXT_VER1 = '00000001'X	 !  RMS Context Extraction version 1
    1	   4013 CDEC$ END OPTIONS
    1	   4014  
	   4015 	INCLUDE '($XABDATDEF)'

MYOPEN                                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  42
1.16                            Symbol Table                     4-NOV-1994 21:24:10    [SYSLIB]FORSYSDEF.TLB;1($XABDATDEF)

    1	   4016 !*** MODULE $XABDATDEF ***
    1	   4017 CDEC$ OPTIONS/ALIGN=(RECORDS=PACKED,COMMONS=PACKED)
    1	   4018  ! 
    1	   4019  !         date/time xab definitions
    1	   4020  !                 $xabdatdef
    1	   4021  ! 
    1	   4022  ! 
    1	   4023 	PARAMETER XAB$C_DAT = '00000012'X	 !  xabdat id code 
    1	   4024 	PARAMETER XAB$K_DATLEN_V2 = '00000024'X	 !  Version 2 XABDAT length 
    1	   4025 	PARAMETER XAB$C_DATLEN_V2 = '00000024'X	 !  Version 2 XABDAT length 
    1	   4026 	PARAMETER XAB$K_DATLEN_V54 = '0000002C'X  !  length of XABDAT 
    1	   4027 	PARAMETER XAB$C_DATLEN_V54 = '0000002C'X  !  length of XABDAT 
    1	   4028 	PARAMETER XAB$K_DATLEN = '0000003C'X	 !  length of XABDAT 
    1	   4029 	PARAMETER XAB$C_DATLEN = '0000003C'X	 !  length of XABDAT 
    1	   4030 	STRUCTURE /XABDATDEF/
    1	   4031 	    BYTE      %FILL
    1	   4032 	    BYTE      %FILL
    1	   4033 	    INTEGER*2 %FILL
    1	   4034 	    INTEGER*4 %FILL				 ! HAS SAME COD, BLN, SPARE AND NXT FIELD 
    1	   4035  ! THESE 4 FIELDS ARE COMMON TO ALL XABS AND
    1	   4036  ! HAVE BEEN DEFINED BY $XABDEF
    1	   4037 	    INTEGER*2 %FILL				 ! REVISION !,DEFINED IN $XABDEF,SINCE COMMON TO DAT & RDT 
    1	   4038 	    INTEGER*2 %FILL				 !  spare 
    1	   4039 	    INTEGER*4 %FILL(2)			 !  revision date & time,defined in $xabdef 
    1	   4040 	    UNION
    1	   4041 	        MAP
    1	   4042 	        INTEGER*4 XAB$Q_CDT(2)			 !  creation date & time 
    1	   4043 	        END MAP
    1	   4044 	        MAP
    1	   4045 	            INTEGER*4 XAB$L_CDT0
    1	   4046 	            INTEGER*4 XAB$L_CDT4
    1	   4047 	        END MAP
    1	   4048 	    END UNION
    1	   4049 	    UNION
    1	   4050 	        MAP
    1	   4051 	        INTEGER*4 XAB$Q_EDT(2)			 !  expiration date & time 
    1	   4052 	        END MAP
    1	   4053 	        MAP
    1	   4054 	            INTEGER*4 XAB$L_EDT0
    1	   4055 	            INTEGER*4 XAB$L_EDT4
    1	   4056 	        END MAP
    1	   4057 	    END UNION
    1	   4058 	    UNION
    1	   4059 	        MAP
    1	   4060 	        INTEGER*4 XAB$Q_BDT(2)			 !  backup date and time 
    1	   4061 	        END MAP
    1	   4062 	        MAP
    1	   4063 	            INTEGER*4 XAB$L_BDT0
    1	   4064 	            INTEGER*4 XAB$L_BDT4
    1	   4065 	        END MAP
    1	   4066 	    END UNION
    1	   4067 	    UNION
    1	   4068 	        MAP
    1	   4069 	        INTEGER*4 XAB$Q_RCD(2)			 !  Recorded date and time 
    1	   4070 	        END MAP
    1	   4071 	        MAP
    1	   4072 	            INTEGER*4 XAB$L_RCD0

MYOPEN                                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  43
1.16                            Symbol Table                     4-NOV-1994 21:24:10    [SYSLIB]FORSYSDEF.TLB;1($XABDATDEF)

    1	   4073 	            INTEGER*4 XAB$L_RCD4
    1	   4074 	        END MAP
    1	   4075 	    END UNION
    1	   4076 	    UNION
    1	   4077 	        MAP
    1	   4078 	        INTEGER*4 XAB$Q_EFF(2)			 !  Effective date and time 
    1	   4079 	        END MAP
    1	   4080 	        MAP
    1	   4081 	            INTEGER*4 XAB$L_EFF0
    1	   4082 	            INTEGER*4 XAB$L_EFF4
    1	   4083 	        END MAP
    1	   4084 	    END UNION
    1	   4085 	END STRUCTURE	! XABDATDEF
    1	   4086 CDEC$ END OPTIONS
    1	   4087  
	   4088 	RECORD /FABDEF/ FAB
	   4089 	RECORD /RABDEF/ RAB
	   4090 	INTEGER*4 LUN
	   4091 C
	   4092 	STRUCTURE /XABUNION/
	   4093 	  UNION
	   4094 	    MAP
	   4095 	      RECORD /XABDEF/ XAB
	   4096 	    END MAP
	   4097 	    MAP
	   4098 	      RECORD /XABDATDEF/ XABDAT
	   4099 	    END MAP
	   4100 	  END UNION
	   4101 	END STRUCTURE
	   4102 	RECORD /XABUNION/ XABU
	   4103 C
	   4104 	COMMON /GETDATEINFO/ XABU
	   4105 C
	   4106 	INTEGER*4 SYS$OPEN,SAVE
	   4107 C
	   4108 	SAVE = FAB.FAB$L_XAB			!\ Insert my XAB at the start
	   4109 	FAB.FAB$L_XAB = %LOC(XABU)		!/ of the XAB chain.
	   4110 
	   4111 	XABU.XAB.XAB$B_COD = XAB$C_DAT		!\ Tell RMS that I want the
	   4112 	XABU.XAB.XAB$B_BLN = XAB$C_DATLEN	!/ XABDAT stuff.
	   4113 
	   4114 	XABU.XAB.XAB$L_NXT = SAVE		! Link in the original XAB
	   4115 						! chain.
	   4116 
	   4117 	MYOPEN = SYS$OPEN(FAB)			! Do the $OPEN, note that
	   4118 						! this example doesn't do
	   4119 						! a $CONNECT; not needed since
	   4120 						! we're going to close the file
	   4121 						! immediately anyway
	   4122 	IF (MYOPEN) THEN
	   4123 	ENDIF
	   4124 	RETURN
	   4125 	END

MYOPEN                                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  44
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76



PROGRAM SECTIONS

    Name				 Bytes   Attributes

  1 $DATA$                                 200 NOPIC CON REL LCL NOSHR NOEXE   RD   WRT OCTA
  2 $BSS$                                  600 NOPIC CON REL LCL NOSHR NOEXE   RD   WRT OCTA
  3 $IODATA$                               200 NOPIC CON REL LCL NOSHR NOEXE   RD   WRT OCTA
  4 $CODE$                                6312   PIC CON REL LCL   SHR   EXE NORD NOWRT OCTA
  5 $LINK$                                 840 NOPIC CON REL LCL NOSHR NOEXE   RD NOWRT OCTA
  6 EDB                                 454336 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
  7 EDB_HEADER                              20 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
  8 HDB                                    996 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
  9 HK                                    3912 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 10 L1_HEADERS                             644 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 11 DIAG                                    48 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 12 L1INFO                                  40 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 13 FILE                                   160 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 14 DATES                                   32 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 15 EPHDATA                              29384 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA
 16 GETDATEINFO                             60 NOPIC OVR REL GBL NOSHR NOEXE   RD   WRT OCTA

    Total Space Allocated               497784


ENTRY POINTS

    Address   Type  Name  
                          
  4-00001800  I*4   MYOPEN


VARIABLES

    Address   Type  Name     Address   Type  Name
                                                 
      **      I*4   LUN  REG-00000000  I*4   SAVE


RECORDS

    Address   Name  Structure        Bytes     Address   Name  Structure        Bytes
                                                                                     
      **      FAB   FABDEF              80  16-00000000  XABU  XABUNION            60
      **      RAB   RABDEF              68                                           



MYOPEN                                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  45
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76

FUNCTIONS AND SUBROUTINES REFERENCED

  Type  Name          
                      
  I*4   SYS$OPEN      

MYOPEN                                                           1-APR-1997 13:02:47    DEC Fortran V6.2-508                Page  46
1.16                            Symbol Table                    26-APR-1995 16:22:02    WIND_BUILD_L1_HEADER.FOR;76



  +---------------------------------------------------+
  |               KEY TO ADDRESS CODE FORMATS         |
  |   ppp-oooooooo  - In Psect ppp, Offset oooooooo   |
  |   ***-********  - External                        |
  |               # - Suffix: Also In Registers       |
  |   REG-rrrrrrrr  - In Register rrrrrrrr            |
  |   REG-########  - In Various Registers            |
  |        **       - Not Used; Not Allocated         |
  +---------------------------------------------------+


COMMAND QUALIFIERS

  /ALIGNMENT=(COMMONS=(PACKED,NOMULTILANGUAGE),RECORDS=PACKED)
  /ASSUME=(ACCURACY_SENSITIVE,BACKSLASH,NODUMMY_ALIASES,NOUNDERSCORE)
  /CHECK=(ASSERTIONS,BOUNDS,FORMAT,FP_EXCEPTIONS,OVERFLOW,&
  /DEBUG=(NOSYMBOLS,TRACEBACK)
  /DESIGN=(NOCOMMENTS)
  /SHOW=(DICTIONARY,INCLUDE,MAP,PREPROCESSOR)
  /STANDARD=(NOSEMANTIC,NOSOURCE_FORM,NOSYNTAX)
  /WARNINGS=(NOALIGNMENT,NOARGUMENT_CHECKING,DECLARATIONS,GENERAL,NOTRUNCATED_SOURCE,UNCALLED,
             UNINITIALIZED,UNREACHABLE,UNUSED)
  /NOAUTOMATIC  /BLAS=NOMAPPED  /CONVERT=NATIVE  /NOCROSS_REFERENCE  /NOD_LINES  /ERROR_LIMIT=30  /EXTEND_SOURCE
  /NOPAD_SOURCE  /NOF77  /FLOAT=G_FLOAT  /IEEE_MODE=FAST  /ROUNDING_MODE=NEAREST
  /GRANULARITY=QUADWORD  /INSTRUCTION_SET=FLOATING  /INTEGER_SIZE=32  /NOMACHINE_CODE
  /MATH_LIBRARY=ACCURATE  /NAMES=UPPERCASE  /OPTIMIZE=(LEVEL=4,UNROLL=0)  /REAL_SIZE=32  /NORECURSIVE
  /NOSEPARATE_COMPILATION  /NOSYNCHRONOUS_EXCEPTIONS  /NOSYNTAX_ONLY  /TERMINAL=NOSTATISTICS  /NOTIE  /VMS
  /NOANALYSIS_DATA
  /NODIAGNOSTICS
  /INCLUDE=(.FOR,.f,FORT$INCLUDE:.FOR,FORT$INCLUDE:.f)
  /LIST=SMS1:[WIND.SOFTWARE.LZ]WIND_BUILD_L1_HEADER.LIS;111
  /OBJECT=SMS1:[WIND.SOFTWARE.LZ]WIND_BUILD_L1_HEADER.OBJ;70
  /NOLIBRARY
   sys$lib=SYS$COMMON:[SYSLIB]FORSYSDEF.TLB;1

COMPILER: DEC Fortran V6.2-508-274F

COMPILATION STATISTICS

  CPU time:          4.42 seconds
  Elapsed time:      6.88 seconds
  Pagefaults:         333
  I/O Count:          119
